\documentclass[hyperref,bachelorofscience,fleqn]{cgvpub}
%weitere Optionen zum Ergänzen (in eckigen Klammern):
% 
% bibnum	numerische Literaturschlüssel
% final 	für Abgabe	
% lof			Abbildungsverzeichis
% lot			Tabellenverzeichnis
% noproblem	keine Aufgabenstellung
% notoc			kein Inhaltsverzeichnis
% twoside		zweiseitig
\author{Adrian Bielefeldt}
\title{Title}
\birthday{15. October 1994}
\placeofbirth{Dresden}
\matno{3694323}
\betreuer{Prof. Dr. Markus Krötzsch}
\bibfiles{literatur}
\problem{problem}
\copyrighterklaerung{copyright stuff}
\acknowledgments{Acknowledgements}
\abstracten{abstract text English}

\usepackage{rotating}
\usepackage{float}
\restylefloat{table}
\usepackage{makecell}
\renewcommand{\cellalign}{tl}
\usepackage{tabularx}
\usepackage{todonotes}
\usepackage{adjustbox}

\setcounter{tocdepth}{2}

\begin{document}
\chapter{Introduction}
Motivation

\chapter{Preliminaries}
\section{Wikidata}
Wikidata is the knowledge base sister project of Wikipedia. It is a public, open database system that, at its core, stores statements about specific items. The basic unit of information is a triple subject-predicate-object stating an item (subject) has a property (predicate) which is either another item or a value of some kind (object). Triples store the relations of entities with each other or with specific data. An entity is either an item, which represents a topic, concept or real world entity, or a property, which denotes a relation an item has to another or with a value. They have numeric identifiers that are prefixed with Q and P and will be referred to as Q- and P-IDs, respectively. In the future there will be a third entity type, lexeme. This is already incorporated into some constraints, but as of September 2018 they are not deployed. A value is one of several data types shown in Table \ref{tab_datatypes}, although it is also possible to use \emph{none} or \emph{some} as values for statements that have no value (akin to negation) or have a currently unknown value. Every property determines the data type it accepts as an object. \\

\begin{table}[H]
\caption{Wikidata data types}\label{tab_datatypes}
\begin{tabularx}{\textwidth}{llp{8.5cm}}
Data type & Fields & Description \\
\hline
commons media & file (string) & name of a file in the "File" namespace on Wikimedia Commons \\
globecoordinate & \makecell{latitude (float) \\ longitude (float) \\ precision (float) \\ globe (URI)} & coordinates on a given celestial body or geographic standard \\
item & item (Q-ID) & the Q-ID of an item on Wikidata \\
property & property (P-ID) & the P-ID of an item on Wikidata \\
string & string (string) & simple string literal that does not need to be translated into different languages \\
monolingual text & string (string) & simple string literal that is written in one specific language and not to be translated \\
quantity & \makecell {amount (decimal) \\ upperBound (decimal) \\ lowerBound (decimal) \\ unit (URI or 1)} & quantity of a specified unit (or none) with uncertainty \\
time & \makecell {time (string) \\ calendarmodel (URI) \\ precision (integer)} & time as a string according to calendarmodel (julian or gregorian), with precision mapping to orders of magnitude (e.g.. 10 years, months) \\
URL & url(URL) & a general URL for an external resource \\
mathematical expression & formula (string) & string that is formatted to display as a formula \\
external identifier & id (string) & string representing an identifier of an external system \\
geographic shape & map data (string) & name of a file in the "Data" namespace on Wikimedia Commons \\
tabular data & tabular data (string) & name of a file in the "Data" namespace on Wikimedia Commons \\
\end{tabularx}
\end{table}
\todo[inline]{For globe(URI): JSON data model states "typically refer to a data item on wikidata.org", which I would read as can be any URI}

While this is similar to RDF and Wikidata has in fact been exported as RDF \cite{EGKMV2014}, the data structure is more complex than simple triples. It allows to store additional information about statements. This is done via a statement ID, which is assigned to every triple storing information about an item. Every statement can be referenced by qualifiers, which consist of the corresponding statement id, a predicate and an object. Qualifiers provide contextual information for statements. The most common context is the time frame in which the statement was accurate, e.g. stating the start and end times of a head of state, but other information is possible, e.g. determination method for measurements or the elevation above sea level for the highest point. Additionally, references can be added to statements. References support the claim by citing the source and possibly additional information, e.g. when it was retrieved or when the source was published as property-object pairs.

Other information regarding items like labels and descriptions in different languages as well as aliases and site links to other Wikimedia projects are also part of the data model but are not subject to constraints and are thus not explored further.
\section{Datalog}
Datalog is a logic query language. It is fully declarative and uses rules to derive additional knowledge from given facts. The most basic domain element in datalog is a \emph{constant}, which will be denoted as \emph{someConstant}. In the context of Wikidata, any item or property, e.g. \emph{Earth} (Q2) or \emph{head of government} (P6), could be represented as a constant. Relations in datalog are expressed using \emph{predicates} with a specified arity \(n\), written as predicate\([n]\). To stay close to Wikidata in our examples let us take the predicate triple\([3]\) as an example. This would be used to express the \emph{item}-\emph{property}-\emph{value} relation with each position representing one part of the triple.\\
Additionally, datalog also provides \emph{variables}, which will be capitalized like \(X\). The sets of predicates {\bf P}, constants {\bf C} and variables {\bf V} are mutually disjoint. Constants and variables are collectively known as \emph{terms} and are, together with predicates, used to form \emph{atoms}. An atom has the form predicate\((t_1, \ldots , t_n)\) with \(n\) as the arity of the predicate and \(t_1,\ldots,t_n\) terms.\\
Atoms are the building blocks of \emph{rules}, which are used to derive information in datalog. A rule is a premise that implies a conclusion, and both are conjunctions of atoms.
Let \(P_n\) denote  premise atoms and \(C_n\) the conclusion atoms. The variables used in one rule are divided into three mutually disjoint sets \(V_p\), \(V_c\), and \(V_r\) which are the variables occurring only in its premise atoms, only in its conclusion atoms, and occurring in both, respectively. The general from of an existential rule is (with \(k \in \mathbb{N}^+\), \(l \in \mathbb{N}\))
\begin{equation}
\forall V_p \forall V_r.(\exists V_c.C_1 \wedge \ldots \wedge C_k \leftarrow P_1 \wedge \ldots \wedge P_l)
\end{equation}

\(V_c\) are called existential variables. If \(V_c = \emptyset\) the rule is called a \emph{datalog rule} and if \(l = 0\) it is called a \emph{fact}. If a fact contains no variables but only constants it is a \emph{ground rule}. Since all \(V_p\) and \(V_r\) are  quantified, the preceding universal quantifiers \(\forall V_p \forall V_r\) will be omitted for the rules presented in this work.

Within the rule predicates we can differentiate between two different schemas: the \emph{extensional schema} and the \emph{intensional schema}, called EDB and IDB (extensional/intensional database). An EDB predicate may only occur in the premise of a rule, meaning it can never be derived. All predicates that appear in the conclusion at least once are IDB predicates.

For the following example, taken from Wikidata, descriptive names will be used instead of the IDs to increase readability. The individual entities and properties are introduced with their ID beforehand so the example can be retraced. The species \emph{blue whale} (Q42196) has the \emph{parent taxon} (P171) \emph{balaenoptera} (Q133320), which in turn has the parent taxon \emph{rorqual} (Q232829). The predicates used are triple\_EDB\([3]\) as the input and isInTaxon\_IDB\([2]\), which will be derived. The basic facts are:
\[\text{triple\_EDB}(\text{blue whale}, \text{parent taxon}, \text{balaenoptera})\]
\[\text{triple\_EDB}(\text{balaenoptera}, \text{parent taxon}, \text{rorqual})\]
From this we can draw conclusions. The first step is to represent the already existing facts as IDB:
\[\text{isInTaxon\_IDB}(X, Y) \leftarrow \text{triple\_EDB}(X, \text{parent taxon}, Y)\]
Finally the transitive closure of this relation can be derived with
\[\text{isInTaxon\_IDB}(X, Y) \leftarrow \text{isInTaxon\_IDB}(X, Z) \wedge \text{isInTaxon\_IDB}(Z, Y)\]

\chapter{Property Constraints}

To improve the data quality, to help editors avoid common mistakes and to clarify the usage of properties, Wikidata allows constraints to be defined on properties. They are, however, not firm rules and exceptions can and should be made if necessary. A property constraint says something about the way a property may or may not be used. This can mean simple restrictions on the statement a property is part of, e.g. that only certain values are allowed, or more complex requirements on connected parts of the data graph, e.g. that the value of a statement with this property should have certain statements. In Table \ref{tab_property_constraints} you can find the existing property constraints. Afterwards the constraints will be explained in detail and a basic approach for their modelling given. For constraint that cannot be modelled, reasoning for this assessment is included.

To apply a constraint to a property, a statement <property> <P2302> <constraint> is added to the properties item page, where <property> is the property that should be constrained, <P2302> (property constraint) denotes that the property has a constraint and <constraint> is the specific constraint. Note that a constrained statement means a statement whose predicate is a property that has a specific constraint. A simple example for this would be \emph{distinct values} (Q21502410) stating that values of the property must be unique across all constrained statements. For this case no additional information regarding the constraint is necessary and violation could be found by surveying all constrained statements and comparing their values.\\
Constraints can be further specified by using qualifiers on the constraint statement. These qualifiers are either optional or mandatory and may be applied once or multiple times. For example, the \emph{none of} constraint (Q52558054) states that values for the specific property may not be in a given set of disallowed values. This set is specified using qualifiers with property \emph{item of} (P2305), which list all the disallowed values. At least one such qualifier must be present for the statement.\\
More complex dependencies are also possible. A constraint can depend on all constrained statements of a specific item (\emph{single value} constraint [Q19474404]), on all statements of the item specified as the value of a constrained statement (\emph{value requires statement} constraint [Q21510864]) or on all statements using the subclassOf-predicate (\emph{type} constraint [Q21503250]).

Table \ref{tab_property_constraints} shows all constraints that are used as of September 2018. It is roughly sorted by how difficult it is to model the given constraint using logical rules, based on the required expressive features and pre-processing. These required features are conditions that cannot natively be expressed in datalog and would require some kind of pre-processing of the dataset. Four constraints do not need any pre-processing except for loading the data into datalog as ground rules. Six can be solved if constant inequality is defined. This can be easily solved with brute force but will be improved in section \ref{sec_inequality}. A further seven require negation of a specific fact which can be achieved with reasonable effort. The last ten \todo{maybe type can be done in some way} are not deemed translatable because they require a feature that cannot be reasonably emulated in datalog. The feature mostly needed is a general form of negation that would allow to test for the non-existence of a derived fact. Other features needed for these constraints are regular expressions, which could theoretically be translated but would require large amounts of pre-processing, value comparison, and finally web requests to test if a link is valid.

\begin{table}[H]
\caption{property constraints}\label{tab_property_constraints}
\begin{tabularx}{\textheight}{rlll}
\makecell{\# constrained\\ properties} & Identifier & Name & Required Features \\
\hline
1410 & Q53869507 & Scope &  \\
781 & Q21502838 & Conflicts with &  \\
27 & Q52004125 & Allowed entity types &  \\
17 & Q52558054 & None of &  \\
\hline
2843 & Q21502410 & Distinct value & Inequality \\
343 & Q21514353 & Allowed units & Inequality \\
303 & Q21510851 & Allowed qualifiers & Inequality \\
116 & Q21510859 & One of & Inequality \\
3 & Q52060874 & Single best value & Inequality \\
1 & Q52712340 & One-of qualifier value & Inequality \\
\hline
4265 & Q21503247 & Item requires statement & Negation (statement non-existence) \\
244 & Q21510864 & Value requires statement & Negation (statement non-existence) \\
119 & Q21510855 & Inverse & Negation (statement non-existence) \\
33 & Q21510862 & Symmetric & Negation (statement non-existence) \\
13 & Q21510857 & Multi-value & Negation, Count (up to two) \\
2909 & Q19474404 & Single value & Inequality, Negation (qualifier non-existence) \\
203 & Q21510856 & Mandatory qualifier & Negation (qualifier non-existence) \\
\hline
2613 & Q21503250 & Type & Negation (derived fact negation) \\
707 & Q21510865 & Value type & Negation (derived fact negation) \\
3021 & Q21502404 & Format & Regular expressions \\
188 & Q21510860 & Range & Value comparison \\
106 & Q52848401 & Integer & Regular expressions \\
65 & Q51723761 & No bounds & Negation \\
53 & Q21510852 & Commons link & Web request \\
10 & Q54554025 & Link & Negation \\
6 & Q21510854 & Difference within range & Value comparison \\
1 & Q25796498 & Contemporary constraint & Negation \\
\end{tabularx}
\end{table}

\section{Rules}
Table \ref{tab_property_constraints} shows that most constraints cannot be modelled without at least some amount of preprocessing. Only \emph{scope}, \emph{conflicts with}, \emph{allowed entity types} and \emph{none of} can be modelled directly. This is due to the fact that \emph{conflicts with} and \emph{none of} exclude a limited and specified set of statements from validity and these cases can thus be directly taken as violations. \emph{scope} and \emph{allowed entity types} work very similar, since there are only three respectively two possible values and violations are simply the options that have not been allowed. The rules for these constraints are described in section \ref{sec_simple_constraints}.\\

A problem that occurs multiple times is the need to determine inequality between constants. \emph{distinct value}, \emph{allowed units}, \emph{allowed qualifiers}, \emph{one of}, \emph{single best value} and \emph{one-of qualifier value} each require a rule to determine if a value, unit or property is not equal to another. To this end a certain amount of preprocessing is necessary, most notably the extraction of all constant pairs whose inequality has to be determined for finding the violations. To avoid putting and undue amount of processing outside of datalog this extraction will not check more than that the constant is in the right position relative to the constrained statement, e.g., all values on statements constrained by \emph{distinct value} or all qualifiers on statements constrained by \emph{allowed qualifiers}. From this set inequality will be generated, different versions of which will be introduced in section \ref{sec_inequality} and evaluated with regards to their performance in section \ref{sec_inequality_evaluation}.\\

Negation as a general problem cannot be solved in datalog. One could pre-process every necessary fact to be negated and add this to the ground facts, but this is not the purpose of this work. However, not all constraints require a general negation. \emph{item requires statement}, \emph{value requires statement}, \emph{inverse }and \emph{symmetric} are all violated if a statement does not exist on a specific item. This problem can be solved with limited amounts of preprocessing by leveraging a preprocessed statement order per item and 'iterating' through the statements until the required conditions are met.\\
A similar approach can be taken to find items with exactly one statement matching certain criteria, required for 	\emph{multi-value}. The idea is to ask the question if a second statement exists, then evaluating it as above. Both methods will be explained in section \ref{sec_statement_non-existence}.

\subsection{Representation of Wikidata as Facts}
To represent the content of Wikidata as facts the following predicates are introduced:
\begin{table}[H]
\caption{EDB predicates}\label{tab_predicates}
\begin{tabular}{llp{8.5cm}}
Predicate & Positions & Description \\
\hline
statement\_EDB & \makecell{statementID \\ entityID \\ propertyID \\ value (entityID or string)} & represents basic statements \\
\hline
qualifier\_EDB & \makecell{statementID \\ propertyID \\ value} & represents qualifiers on statements \\
\hline
reference\_EDB & \makecell{statementID \\ reference hash \\ propertyID \\ value} & represents references on statements; reference hash groups the property-value pairs belonging to one reference \\
\hline
item\_EDB & entityID & marks an entity as an item \\
property\_EDB & entityID & marks an entity as a property \\
\hline
unit\_EDB & \makecell{value \\ unitID} & denotes which unit a value has \\
\hline
rank\_EDB & \makecell{statementID \\ rank} & denotes the rank a statement has
\end{tabular}
\end{table}

\subsection{Terminology}
\begin{table}[H]
\caption{abbreviations}\label{tab_abbreviations}
\begin{tabular}{ll}
Shorthand & Description \\
\hline
constrained statement & statement with the constrained property as predicate \\
constrained qualifier & qualifier with the constrained property as predicate \\
constrained reference & reference with the constrained property as predicate \\
constrained entity & entity with a constrained statement \\
entity statement & statement on the same entity of a constrained statement \\
value statement & statement on the value of a constrained statement
\end{tabular}
\end{table}

\subsection{Task}
Each property constraint will be modelled and evaluated as one set of rules per property per constraint, meaning each violating statement will be of a form similar to
\begin{align*}
&\text{violation\_statement}(S, E, \text{propertyConstant}, V) &\leftarrow \text{atoms determining the violation} \\
&\text{violation\_qualifier}(S, \text{propertyConstant}, V) &\leftarrow \text{atoms determining the violation} \\
&\text{violation\_reference}(S, H, \text{propertyConstant}, V) &\leftarrow \text{atoms determining the violation}
\end{align*}
where propertyConstant denotes the constrained property. The variables \(S\), \(I\), \(V\), and \(H\) are used for statement ID, entity ID, value and reference hash, respectively.

The task for each constraint is thus: Given the constraint and a constrained property, potentially with qualifiers, which rule finds all violations of the rule in a given set of triples, qualifiers and references if applicable? The given rule set should return all violations if queries with the following atoms:
\begin{align*}
&\text{violation\_statement}(S, E, P, V) \\
&\text{violation\_qualifier}(S, P, V) \\
&\text{violation\_reference}(S, H, P, V)
\end{align*}

\chapter{Wikidata constraints explained}
This section will explain all interesting, meaning translatable or partially translatable, currently used property constraints on Wikidata. They will be presented roughly in descending order of the number of properties with this constraint, although constraints with similar function will be explained directly after one another. Additionally, all constraints that were considered untranslatable are listed at the and, each with a short explanation as to why they were placed in that group.

Every section describing a constraint will consist of two subsections: the constraint explanation and the rules.

{\bf Constraint:} This subsection starts with a table showing basic properties of the constraint. These include the required data, relevant qualifiers, and possible violations of the constraint. The required data states which part of the data in relation to the constrained statement are restricted or need to exist. The qualifiers list their cardinality, meaning if they are required and if they may be used multiple times, and a short description. The violations list the conflicting (part of a) statement in relation to the constrained statement. The first constraint, \emph{property scope}, will be used as an example to explain the table in detail.

{\bf Rules:} Most constraints require more data than just the statements, qualifiers and references. This can include additional data from Wikidata to be provided as facts using the introduced predicates (see Table \ref{tab_predicates}), inequalities to be established as a pre-processing step (see Section \ref{sec_inequality}) or preparations to determine specific kinds of negation (see Section \ref{sec_statement_non-existence}). Afterwards, the rules necessary to determine violations are described.

\section{Simple Constraints}\label{sec_simple_constraints}
This section contains constraints that do not require any additional features and can be translated into rules directly based on the facts introduced from Wikidata.

\subsection{Scope (Q53869507)}
\paragraph{Constraint}
The \emph{property scope} constraint specifies if a property may be used as predicate in a statement, qualifier or reference.
\begin{table}[H]
\caption{property scope constraint (Q53869507)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & constrained statement, qualifier and reference \\
\hline
Qualifiers & \makecell{\emph{property scope} (P5314) -- 1..3 \\ must be \emph{as main value} (Q54828448), \emph{as qualifier} (Q54828449) \\ or \emph{as reference} (Q54828450) \\ specifies allowed use in statements, qualifiers or references} \\
\hline
Violation & constrained property in a position that is not allowed \\
\hline
\end{tabularx}
\end{table}

The required data specifies which data, in relation to the constrained statement, needs to be evaluated to conclude if the constraint was violated. The used abbreviations are listed in Table \ref{tab_abbreviations}. In this case this is simply each statement, qualifier or reference whose predicate is the constrained property.\\
The \emph{property scope} constraint requires the scope, meaning statement, qualifier or reference, to be set via qualifier \emph{property scope} (P5314). The cardinality is 1..3 because it is mandatory and has only three possible values.\\
It is violated if a statement, qualifier or reference has a predicate with the \emph{property scope} constraint that does not allow this scope.\\

\paragraph{Rules}
The property scope constraint requires no context information to be violated; the triple, qualifier, or reference with the constrained property is enough. This means violations can be found using these rules:
\begin{align*}
\text{violation\_triple}(S, I, \text{propertyConstant}, V) &\leftarrow \text{statement\_EDB}(S, I, \text{propertyConstant}, V)\\
\text{violation\_qualifier}(S, \text{propertyConstant}, V) &\leftarrow \text{qualifier\_EDB}(S, \text{propertyConstant}, V)\\
\text{violation\_reference}(S, \text{propertyConstant}, V) &\leftarrow \text{reference\_EDB}(S, H, \text{propertyConstant}, V)
\end{align*}
Which of these rules need to be used depends on the values of the \emph{property scope} qualifier. If a concrete constrained on a property does not have \emph{as main value} as a value of the qualifier, the first rule is used. The case for \emph{as qualifier} and \emph{as reference} is analogue with the second and third rule, respectively.

\subsection{Conflicts with (Q21502838)}
\paragraph{Constraint}
The \emph{conflicts with} constraint forbids statements on constrained entities whose predicate is a specified \emph{conflicting property}. If \emph{conflicting values} have been specified as well, the constraint is weakened and only violated by statements if in addition to the predicate being a \emph{conflicting property}, the object is one of the \emph{conflicting values}.
\begin{table}[H]
\caption{Conflicts-with constraint (Q21502838)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & entity statements \\
\hline
Qualifiers & \makecell{\emph{conflicting property} (P2306) -- 1 \\ property that may not be predicate of entity statements \\
\emph{conflicting values} (P2305) -- 0..* \\ values that may not be objects of entity statements with the \emph{conflicting property}} \\
\hline
Violation & \makecell{entity statement with the conflicting property \\ entity statement with the conflicting property and one of the conflicting values} \\
\hline
\end{tabularx}
\end{table}

\paragraph{Rules}
The conflicts-with constraint is violated if another statement on the same item either has a conflicting property or a conflicting property and a conflicting value depending on specified qualifiers. It depends on a conjunction (\(O\) denoting another statement ID, \(C\) another value) and a violation for a conflicts-with constraint is thus either
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow\\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{}\\
&\text{statement\_EDB}(O, I, \text{conflictingPropertyConstant}, C)
\end{split}
\end{equation*}
for constraints with no conflicting values specified or one
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow\\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{}\\
&\text{statement\_EDB}(O, I, \text{conflictingPropertyConstant}, \text{conflictingValueConstant})
\end{split}
\end{equation*}
for each conflicting value if specified.\\

\subsection{Allowed entity types (Q52004125)}
\paragraph{Constraint}
The \emph{allowed entity types} constraint limits if a property may be used in a statement whose subject is an item, a property or a lexeme, although as of September 2018 lexemes are not deployed.

\begin{table}[H]
\caption{Allowed entity types constraint (Q52004125)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & constrained statements and entity types\\
\hline
Qualifiers & \makecell{allowed entity type (P2305) -- 1..3 \\ must be \emph{Wikibase item} (Q29934200), \emph{Wikibase property} (Q29934218) \\ or lexeme (Q51885771); \\ specifies the entity type the property may be used on} \\
\hline
Violation & \makecell{constrained statement on an entity of a type unequal to all allowed types} \\
\hline
\end{tabularx}
\end{table}

Since there are only three options (and only two in use), violations can be found without inequality by finding the statement\_EDB with the constrained property whose subject is of the type that is not allowed, meaning either \emph{Wikibase item} or \emph{Wikibase property}.

\paragraph{Rules}
The allowed entity types constraint is violated by a statement with the wrong entity type.  Constraints regarding the lexeme entity type can be ignored since they are currently not used. The Violations depend on a simple conjunction:
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge \text{item}(I)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge \text{property}(I)
\end{split}
\end{equation*}
The first rule are created for all \emph{allowed entity type} constraints whose \emph{allowed entity type} does not contain \emph{Wikibase item}. The second rule works analogue for \emph{Wikibase property}.

\subsection{None of (Q52558054)}
\paragraph{Constraint}
The none of constraint restricts the values that the property may refer to by listing a set of values as forbidden.

\begin{table}[H]
\caption{None of constraint (Q52558054)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & constrained statements, qualifiers and references \\
\hline
Qualifiers & \makecell{\emph{forbidden value} (P2305) -- 1..* \\ values that may not be object of a constraint statement, qualifier or reference} \\
\hline
Violation & \makecell{constrained statement, qualifier or reference with a forbidden value} \\
\hline
\end{tabularx}
\end{table}

\paragraph{Rules}
The none of constraint simply forbids certain values for properties, thus effectively prohibiting certain triples, qualifiers and references. The rules, depending on nothing but specific database entries, are
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, \text{forbiddenValueConstant}) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, \text{forbiddenValueConstant})
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_qualifier}&(S, \text{propertyConstant}, \text{forbiddenValueConstant}) \leftarrow \\
&\text{qualifier\_EDB}(S, \text{propertyConstant}, \text{forbiddenValueConstant})
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_reference}&(S, \text{propertyConstant}, \text{forbiddenValueConstant}) \leftarrow \\
&\text{reference\_EDB}(S, H, \text{propertyConstant}, \text{forbiddenValueConstant})
\end{split}
\end{equation*}
Given a specified constraint, each of the three rules is created once for each \emph{forbidden value}.

\section{Constraints using Inequality}\label{sec_constraints_using_inequality}
All translatable constraints except the four covered in the previous section require inequality in some way or another. This means it is necessary to extract additional information during pre-processing, namely the constants for which inequality needs to be stated. Each constraint will list the possible unequal entities in relation to the constrained statement. Multiple ways of implementing inequality while keeping the number of rules small will be discussed. Afterwards all constraints that can be translated using inequality will be explained.

\subsection{Approaches}
In every approach it will be necessary to load some basic inequalities into the database. To this end the predicate unequal\_EDB\([2]\) is introduced. Since the goal is to keep the number of applications of this predicate small, an IDB predicate unequal\([2]\) has to be introduced. This leads to the rule
\begin{equation*}
\text{unequal}(X, Y) \leftarrow \text{unequal\_EDB}(X, Y)
\end{equation*}

Given a set of unequal constants \(U\), the task is to generate rules so that for all \( x, y \in U: x \ne y \Rightarrow \text{unequal}(x, y)\).

\subsubsection{Naive}\label{subsubsec_naive}
The naive approach would be to simply add all possible combinations:
\begin{equation*}
\text{for all } x, y \in U, x \ne y \text{ add } \text{unequal\_EDB}(x, y)
\end{equation*}
This can be easily improved using the inverse and adding the following rule:
\begin{equation}\label{equ_inverse}
\text{unequal}(X, Y) \leftarrow \text{unequal}(Y, X)
\end{equation}
Then it is sufficient to add each combination once. To achieve this assume an arbitrary total order \(<\) has been established on the set \(E\):
\begin{equation*}
\text{for all } x, y \in U, x < y \text{ add } \text{unequal\_EDB}(x, y)
\end{equation*}

\subsubsection{Encoding constant strings to establish inequality}\label{subsubsec_encoding}
One way of determining inequality would be to take advantage of the fact that inequality is established in a set of unequal constants \(U\), which can be represented as a string. The idea is to determine the set of characters used in \(U\), set these characters as unequal as outlined in section \ref{subsubsec_encoding} and associate each unequal constant with their characters.\\

An unequal constant \(u \in U\) can be represented a string and be written as \(c_0 \ldots c_{l - 1}\) with \(l = len(u)\) being the length of the string. Denote the set \(C\) as the set of characters occurring in unequal strings. Then \(l_{\max} = \max\limits_{\forall u \in U}(len(u))\) is the length of the longest entity string that occurs in the given data.
Based on this a group of predicates letter\(_i\)\_EDB[8] is introduced where \(0 \equiv i \mod 7\), \(0 \leq i < l_{max} \). 

For each unequal constant string \(u = c_0 \ldots c_{l - 1}\) and \(0 \equiv i \mod 7, 0 \leq i < len(u)\) an atom using predicate letter\(_i\)\_EDB is created as 
\begin{equation*}
\text{letter}_i\text{\_EDB}(e, f(e, i), f(e, i+1), \ldots, f(e, i+6)
\end{equation*}where
\begin{equation*}
f(e, i) = 
\begin{cases}
      c_i & i < len(e) \\
      \text{none} & i \geq len(e)
\end{cases}
\end{equation*}

Now that inequality between all characters and the link between entities and their characters are introduced, the inequality between two entities can be derived by creating the following rules for all predicates letter\(_i\)\_EDB (with \text{letters} short for \(\text{letter}_i\text{\_EDB}(X, A_i, \ldots, A_{i+6}) \wedge\text{letter}_i\text{\_EDB}(Y, B_i, \ldots, B_{i+6})\), \(i \leq j < i + 7\)):
\begin{equation*}
\text{unequal}(X, Y) \leftarrow \text{letters} \wedge \text{unequal}(A_j, B_j)
\end{equation*}
Note that the facts fulfilling \(\text{unequal}(A_j, B_j)\) are created by using the approach outlined in Section \ref{subsubsec_naive} for the set of characters \(C\) in all unequal constants \(U\).	

\subsubsection{Demand-driven materialisation}
The approaches outlined above will always result in all inequalities between the members of \(U\) being materialised. However, the purpose of determining inequality is to assist in finding violations of specific constraints. This means that only some inequalities -- the ones that actually appear in the dataset -- have to be evaluated. The rules can then be limited by introducing a new predicate req\_inequality\([2]\) which will only be derived if a condition occurs in which the inequality must be evaluated.\\

To save space and avoid redundancy the following rules will not explicitly state the inequality requirement predicate. Instead, assume that for every premise of the form \(B_1 \wedge \ldots\wedge B_m \wedge I_1 \wedge I_n\) where \(B_1 .. B_m\) are arbitrary atoms, \(I_1 .. I_n\) are atoms of the form \(\text{unequal}(t_{n_1}, t_{n_2})\) with \(t_{n_1}, t_{n_2}\) terms and all variables amount \(t_{n_1}\) and \(t_{n_2}\) appear in at least one of \(B_1 \ldots B_m\), the rules 
\begin{equation*}
\text{req\_inequality}(t_{n_1}, t_{n_2})
 \leftarrow B_1 \wedge \ldots \wedge B_m
\end{equation*} for all \(n\) are introduced.\\

The rules outlined in Section \ref{subsubsec_encoding} are changed to utilise this new requirement.
\begin{equation*}
\text{unequal}(X, Y) \leftarrow \text{req\_inequality}	(X, Y) \wedge \text{letters} \wedge \text{unequal}(A_j, B_j)
\end{equation*}

\subsection{Distinct values (Q21502410)}
\paragraph{Constraint}
The \emph{distinct values} constraint forbids the existence of two constrained statements with the same object.
\begin{table}[H]
\caption{distinct values constraint (Q21502410)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & constrained statements \\
\hline
Violations & two constrained statements with same value \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}
The constraint can be expanded to cover qualifiers and references as well by setting a \emph{constraint scope} (P4680) qualifier with the respective value. However, as of September 2018 there is no constraint making use of this.

\paragraph{Rules}
The \emph{distinct values} constraint requires two distinct constrained statements with the same value. 
Two constrained statements with the same value can be found via a simple conjunction of two statement\_EDB atoms with the propertyConstant as predicate and a variable \(V\) as value. Since this would mark every constrained statement as a violations because it can fulfil both atoms at the same time, inequality of the statement IDs \(S\) and \(O\) must be tested as well.t
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{} \\
&\text{statement\_EDB}(O, X, \text{propertyConstant}, V) \wedge{} \\
&\text{unequal}(S, O)
\end{split}
\end{equation*}
The rules for qualifiers and reference are analogue.

\subsection{Allowed units (Q21514353)}\label{subsec_3_allowed_units}
\paragraph{Constraint}
The \emph{allowed units} constraint specifies that the value of a constrained statement may only have a unit that is in a set of specific units.

\begin{table}[H]
\caption{Allowed units constraint (Q21514353)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & constrained statements \\
\hline
Qualifiers & \makecell{\emph{allowed unit} (P2305) -- 1..* \\ units that are allowed on values of constrained statements (\emph{none} for dimensionless units)} \\
\hline
Violation & \makecell{constrained statement with a unit unequal to all allowed units} \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

By setting the \emph{constraint scope} (P4680) qualifier on the constraint it can be limited to only affect a subset of statement, qualifier, and reference. As of September 2018 this is not done on any constraint.

\paragraph{Rules}
To handle this constraint inequality between all units need to be established. Then a violation can be identified by finding all statement\_EDB, qualifier\_EDB and reference\_EDB with the constrained property and a unit unequal to all allowed units.
The allowed units constraint needs to determine inequality between all allowed units and each unit on a constrained statement. To this end the units of a triple, qualifier or reference needs to be extracted during pre-processing and their inequality established. Quantities are rendered as string during pre-processing, specifying their value, bounds and unit.

To determine if a violation occurred, the unit of the constrained statement needs to be found. This is done via the unit-predicate as below
\begin{equation*}
\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge \text{unit\_EDB}(V, U)
\end{equation*}
with qualifiers and references treated analogue.

The complete rules require multiple unequal-atoms for all allowed units. Given a set \(A\) of constants, in this case allowed units, \(\text{unequal}(\{A\}, t)\) with an arbitrary term \(t\) is short for \(\bigwedge_{a \in A} \text{unequal}(a, t)\)

Violation are thus
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{} \\
&\text{unit}(V, U) \wedge \text{unequal}(\{A\}, U)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_qualifier}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{qualifier\_EDB}(S, \text{propertyConstant}, V) \wedge{} \\
&\text{unit}(V, U) \wedge \text{unequal}(\{A\}, U)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_reference}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{reference\_EDB}(S, H, \text{propertyConstant}, V) \wedge{} \\
&\text{unit}(V, U) \wedge \text{unequal}(\{A\}, U)
\end{split}
\end{equation*}

\subsection{Allowed qualifiers (Q21510851)}
\paragraph{Constraint}
The \emph{allowed qualifiers} constraint specifies that only a limited set of properties may be used as predicates of qualifiers on a constrained statement.

\begin{table}[H]
\caption{Allowed qualifiers constraint (Q21510851)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & qualifiers on constrained statements \\
\hline
Qualifiers & \makecell{\emph{allowed qualifier} (P2306) -- 1..* \\ properties that may appear in predicates of qualifiers on constrained statements} \\
\hline
Violation & \makecell{constrained statement with a qualifier unequal to all allowed qualifiers} \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

\paragraph{Rules}
To represent a violation of the \emph{allowed qualifiers} constraint in datalog inequality between all specified allowed qualifiers and the properties of qualifiers is required. The constraint is violated if a qualifier on a constrained statement exists that is unequal to all allowed qualifiers. The notation for set inequality as introduced in section \ref{subsec_3_allowed_units} will be used. With \(A\) the set of allowed qualifiers the rule is:
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{} \\
&\text{qualifier\_EDB}(S, Q, O) \wedge \text{unequal}(\{A\}, Q)
\end{split}
\end{equation*}

\subsection{One-of (Q21510859)}
\paragraph{Constraint}
The \emph{one-of} constraint limits the values of a constraint statement, qualifier or reference to a set of given values.

\begin{table}[H]
\caption{One-of constraint (Q21510859)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & constrained statements, qualifiers and references \\
\hline
Qualifiers & \makecell{\emph{allowed values} (P2305) -- 1..* \\ values that may be used as objects of a constrained statement} \\
\hline
Violation & \makecell{constrained statement with a value unequal to all allowed values} \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

\paragraph{Rules}
The one-of constraint fits in the pattern established by the previous two constraints and disallows certain property-value combinations in statements, qualifiers and references. Inequality is established between all \emph{allowed values} and the values of statements, qualifiers and references, respectively. With \(A\) the set of allowed values the rules for triple, qualifier and reference are:
\begin{align*}
\text{violation\_triple}(S, I, \text{propertyConstant}, V) &\leftarrow \\
\text{statement\_EDB}(S, I, &\text{propertyConstant}, V) \wedge \text{unequal}(\{A\}, V) \\
\text{violation\_qualifier}(S, \text{propertyConstant}, V) &\leftarrow \\
\text{qualifier\_EDB}(S, &\text{propertyConstant}, V) \wedge \text{unequal}(\{A\}, V) \\
\text{violation\_reference}(S, \text{propertyConstant}, V) &\leftarrow \\
\text{reference\_EDB}(S, H, &\text{propertyConstant}, V) \wedge \text{unequal}(\{A\}, V)
\end{align*}

\subsection{One-of qualifier value (Q52712340)}
\paragraph{Constraint}
The \emph{one-of qualifier value} constraint restricts which \emph{qualifier values} may be used on a qualifier with a given \emph{qualifier property} on a constrained statement.

\begin{table}[H]
\caption{One-of qualifier value constraint (Q52712340)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & constrained statements and their qualifiers \\
\hline
Qualifiers: & \makecell{\emph{qualifier property} (P2306) -- 1 \\ property that, if used as predicate, constrains a qualifier \\
\emph{qualifier values} (P2305) -- 1..* \\ values that are allowed for qualifiers on constrained statements \\ with the \emph{qualifier property} as predicate}\\
\hline
Violation & \makecell{constrained statement with a qualifier with the qualifier property \\ and a value unequal to all qualifier values} \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

\paragraph{Rules}
The one-of qualifier value constraint is violated if a constrained statement has a qualifier with a value unequal to all allowed values. Inequality needs to be established between all values of qualifiers and all allowed values. With the set of allowed Values \(A\) the rules are
\begin{equation*}
\begin{split}
\text{violation\_statement}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{} \\
&\text{qualifier\_EDB}(S, \text{qualifierProperty}, O) \wedge \text{unequal}(\{A\}, O)
\end{split}
\end{equation*}

\section{Constraints using Statement non-Existence}
Several constraints are violated if specific statements do not exist in relation to constrained statements. It is not possible to simply negate said statements and pre-processing every required statement would defeat the purpose of implementing them in datalog. However, non-existence can be derived utilising the order of statements. Three predicates are introduced: first\([2]\), last\([2]\), and next\([2]\), which denote the first and last statement of an item and the following statement to another using their statement IDs.\\

If qualifier non-existence should be tested the predicates have to be adapted, since they do not have a unique identifier. Their order has to be established using the entire set of statement ID, property and value. For this the predicates first\_qualifier\([3]\) and last\_qualifier\([3]\) taking the statement ID, the property and the value and next\_qualifier\([6]\) with ID, property and value for the current and next qualifier are introduced.\\

Using this pre-processed data the approach is to apply a require-predicate to each statement or qualifier. This is require\([3]\) for statements, connecting the statement ID with the constrained property \(p\) and the required term \(t\) and require\([5]\) taking the statement ID, property, and value of a qualifier and linking this with \(p\) and \(t\).\\

For statements the pattern consists of two rules, both utilising the same conjunction \(c = C_1 \wedge .. \wedge C_m\) with arbitrary atoms \(C_n\) which is used to test if the statement does not fulfil the requirement. Then rule one
\begin{equation*}
\text{require}(S, p, t) \leftarrow \text{first}(S, I) \wedge c
\end{equation*}
states that the statement requires the condition and
\begin{equation*}
\text{require}(S, p, t) \leftarrow \text{next}(O, S) \wedge \text{require}(O, p, t) \wedge c
\end{equation*}
propagates this down the statement chain.

For qualifiers the rules are
\begin{equation*}
\text{require}(S, P, V, p, t) \leftarrow \text{first}(S, P, V) \wedge c
\end{equation*}
\begin{equation*}
\text{require}(S, P, V, p, t) \leftarrow \text{next}(O, X, C, S, P, V) \wedge \text{require}(O, X, C, p, t) \wedge c
\end{equation*}

If the last statement of an item or the last qualifier of a statement has require the violation occurred. In the following constraints only the conjunction \(c\) and adjustments to this pattern will be described. The require-propagation is regarded as given.

\subsection{Item requires statement (Q21503247)}\label{subsec_2_item_requires_statement}
The item requires statement constraint requires an additional statement on an item with a statement using the constrained property, possibly also using a specific value from the list of allowed values.
\begin{table}[H]
\caption{item requires statement constraint (Q21503247)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & item statement \\
\hline
Qualifiers & \makecell{required property (P2306) -- 1 \\ property the item statement must have \\ allowed value (P2305) -- 0..* \\ values the item statement may have} \\
\hline
Violation & \makecell{no item statement with required property \\ all item statements with required property have no allowed value} \\
\hline
Dependency &  all item statements\\
\hline
Rule features & negation \\
\hline
\end{tabularx}
\end{table}

An item violates the constraint if it a) has a statement using constrained property as predicate, b1) has no statement using the required property as predicate, or (if allowed values are specified) b2) has only statement using required property as predicate that do not use one of the allowed values as value.\\
While condition a) can easily be tested by a statement\_EDB-atom with the constrained property, condition b1) and b2) pose the question if an item does not have a statement. This is addressed in section [?].

\subsection{Value requires statement (Q21510864)}\label{subsec_2_value_requires_statement}
The value requires statement constraint requires an additional statement on the value of constrained statement, possibly also using a specific value from the list of allowed values. Since the constraint works very similar to item requires statement (see \ref{subsec_2_item_requires_statement}) --- requiring a statement on the value of the constrained statement instead of on the item --- it is not elaborated on.

\subsection{Inverse (Q21510855)}\label{subsec_2_inverse}
The inverse constraint requires an additional statement on the value of a constrained statement with a specific property and the constrained item as value. It is very similar to value requires statement (see \ref{subsec_2_value_requires_statement}), although it does not specify allowed values, since the required statement has one specific value: the constrained item. While this means it could not be modelled exactly as a value requires statement constraint, it would only require very small rule changes and will thus not be elaborated on.

\subsection{Symmetric (Q21510862)}
The symmetric constraint requires an additional statement on the value of a constrained statement with the constrained property and the constrained item as value. It is thus equal to an inverse constraint (see \ref{subsec_2_inverse}) with the same property as constrained property and required property and will not be elaborated on.

\subsection{Multi-value (Q21510857)}
The multi-value constraint specifies that the constrained property should appear in multiple statements of an item or none.

\begin{table}[H]
\caption{Multi-value constraint (Q21510857)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & item statement \\
\hline
Violation & \makecell{constrained item with exactly one constrained statement} \\
\hline
Dependency & all item statements \\
\hline
Rule features & count \\
\hline
\end{tabularx}
\end{table}

To model this constraint a count of statements using the constrained property per item would be needed. Then a violation would be any constrained item with a count of one for the constrained property. Since there is no need for arbitrarily large counts, but only for the difference between one and two, this could be solved explicitly.

\subsection{Single value (Q19474404)}
The single value constraint constrains the values a property may take on a single item. A property marked with the single value constraint can have properties marked as separators, which define exceptions under specific circumstances.
\begin{table}[H]
\caption{single value constraint (Q19474404)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & constrained statement value \\
\hline
Qualifiers & \makecell{separator (P4155) -- 0..* \\ qualifiers that must be different for exception} \\
\hline
Violation & \makecell{two constrained statements with same item and value \\ (exception: statements with separators as qualifiers with different values)} \\
\hline
Dependency & \makecell{without separators: all constrained statements on one item \\ with separators: additionally all qualifiers with separators on those statements }\\
\hline
Rule features & inequality, partially negation \\
\hline
\end{tabularx}
\end{table}

If no separators are specified, two triple form a violation of this constraint if they a) belong to the same item, b) have the same constrained property, and c) have the same value.
If separators are specified, a violation as above can be ignored if the statements each have at least one qualifier with the same separator as predicate and different values or an unequal number of separator qualifiers.\\
In the case without separators the modelling idea would be to find two triples statement\_EDB with the same item and constrained property and test if their id is unequal. If separators were specified a violation would be the two triples and all their separator qualifiers equal or non-existent.
\todo{Since I found the details via looking at the source code, should/can I cite that?}

\subsection{Mandatory qualifier (Q21510856)}
The mandatory qualifier constraint requires that a constrained statement has a qualifier with a specific property.

\begin{table}[H]
\caption{Mandatory qualifier constraint (Q21510856)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & qualifier on constrained statement \\
\hline
Qualifiers & \makecell{required property (P2306) -- 1 \\ qualifier that the statement must have} \\
\hline
Violation & \makecell{constrained statement without a qualifier with the required property} \\
\hline
Dependency & constrained statement and its qualifiers \\
\hline
Rule features & negation \\
\hline
\end{tabularx}
\end{table}

To find violations of this constraint one would find a statement\_EDB with the constrained property, but where no qualifier\_EDB for the statement and with the required property exists.

\subsection{Single best value (Q52060874)}
The single best value constraint requires that only one constrained statement per item has the rank preferred.

\begin{table}[H]
\caption{Single best value constraint (Q52060874)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & item statement rank \\
\hline
Qualifiers & \makecell{separator (P4155) -- 0..* \\ qualifiers that must be different for exception} \\
\hline
Violation & \makecell{items with two constrained statements with rank preferred} \\
\hline
Dependency & all item statements and their rank \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

Modelling the constraint means a count of all constrained statements with rank preferred is necessary, with a violation constituted if an item has a count of two or higher. Since it is only needed to differentiate between one and many, the rules could be written explicitly.

\subsection{Type (Q21503250)}\label{subsec_2_type}
The type constraint requires the existence of either one of a specific statement (instanceOf <class>) or a chain of statements using subclassOf to connect directly (subclassOf* <class>)
or via instanceOf (instanceOf/subclassOf* <class>) for all classes on the constrained item.
\begin{table}[H]
\caption{type constraint (Q21503250)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Required data & chain of statements \\
\hline
Qualifiers & \makecell{relation (P2309) -- 1 \\ must be instance of (Q21503252), subclass of (Q21514624), \\ or instance or subclass of (Q30208840); \\ specifies the relation the constrained item must have to the classes\\
class (P2308) -- 1..* \\ entities that must be reached using the relation} \\
\hline
Violation & constrained item without relation to a class \\
\hline
Dependency & \makecell{statements of constrained items using instanceOf (P31) or subclassOf(P279) \\ all statements using subclassOf (P279) }\\
\hline
Rule features & inequality, negation \\
\hline
\end{tabularx}
\end{table}

If the relation is instanceOf, the constraint can be evaluated like multiple item requires statement constraints (see \ref{subsec_2_item_requires_statement}) by setting the required property to instanceOf (P31) and, for each created item requires statement constraint, the allowed value to one of the classes. \\
For the relations involving subclasses all transitive subclass relationships would be concluded by setting a subclass relationship if a third item can be found that is subclass of one and subclassed by the other item. This would be extended with one step of instanceOf. A violation would then be any constrained item that is not subclass of any of the classes.

\subsection{Value type (Q21510865)}
The value type constraint works like the type constraint (see \ref{subsec_2_type}) except the statement chains are required on the value of the constrained statement instead of the constrained item. It will thus not be expanded upon.

\section{Reasoning for unconsidered constraints}
Multiple constraints have not been described above for different reasons. The most prominent of these is the format constraint (Q21502404) which specifies a regular expressions the values of the constrained property must adhere to. Evaluating these expressions would be theoretically possible but \\
a) primarily results in a large amount of preprocessing and\\
b) does not solve the question of negation, since violations would be values that do not conform to their required regular expression. \\

The integer constraint (Q52848401), which requires values of a constrained property be integers (notably a quantity without decimal places), could easily be seen as a specific format constraint. While precomputing if a value is an integer or not could be done, it would mean that no actually relevant rules would be needed for the evaluation in datalog. \\

Another problem that could not be sensibly solved is the comparison of values, needed for range (Q21510860), difference within range (Q21510854) and contemporary constraint (Q25796498). Range restricts the values of a constrained property within a certain range, difference within range specifies that two item statements should have values within a certain range and contemporary constraint specifies that subject and object of a constrained statement have to have coexisted at some point in time. While it would be possible to extract all values that might need to be compared and precompute the comparison, it would make most of the work precomputing and leave little to be done in datalog.\\

Link constraint (Q54554025), requiring that constraint statements must have one or more references, requires a negation that cannot be concluded except by explicitly precomputing it, which makes the evaluation unnecessary. \\
A similar situation is the no bounds constraint (Q51723761), which requires that quantity values have neither upper nor lower bound. While it would be possible to precompute if a statement has no upper or lower bound, this would shift basically all evaluation logic into precomputing.

And finally commons link constraint (Q21510852) requires that values for a property should be valid links to to Wikimedia Commons. This validity cannot be testes from within datalog since there is no way to query the web for information.

\section{Statement non-existence}\label{sec_statement_non-existence}


\subsection{Item requires statement (Q21503247)}
The item requires statement constraint requires the pre-processing of all item statements. Additionally, inequality between all properties of item statements and the required property as well as between all values and the allowed values has to be established. It occurs in two varieties, depending on if allowed values have been specified or not. The required term \(t\) is the  required property. Without separators the conjunction is
\begin{equation*}
\begin{split}
c_1 = &\text{statement\_EDB}(Q, I, \text{propertyConstant}, X) \wedge{} \\
&\text{statement\_EDB}(S, I, P, V) \wedge \text{unequal}(\text{requiredPropertyConstant}, P)
\end{split}
\end{equation*} \(\)
If a set of allowed values \(A\) has been specified, a second set of require-rules have to be introduced with
\begin{equation*}
\begin{split}
c_2 = &\text{statement\_EDB}(Q, I, \text{propertyConstant}, X) \wedge{} \\
&\text{statement\_EDB}(S, I, \text{requiredPropertyConstant}, V) \wedge \text{unequal}(\{A\}, V)
\end{split}
\end{equation*}
Note that the first set of rules is still required, since the preceding statements do not need to have the required property. In both cases violations can be found with
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{} \\
&\text{statement\_EDB}(O, I, P, X) \wedge \text{last}(O, I) \wedge{} \\
&\text{require}(O, \text{propertyConstant}, \text{requiredPropertyConstant})
\end{split}
\end{equation*}

\subsection{Value requires statement (Q21510864)}
The value requires statement constraint is syntactically very similar to the previous item requires statement constraint. Instead of requiring a statement on the item of a constrained statement it requires it on the value. The pre-processing changes to extracting all value statements along the constrained statements and ordering them. Inequality need to be computed between all properties and all values on value statements. The conjunctions change in the first triple and are:
\begin{equation*}
\begin{split}
c_1 = &\text{statement\_EDB}(Q, R, \text{propertyConstant}, I) \wedge{} \\
&\text{statement\_EDB}(S, I, P, V) \wedge \text{unequal}(\text{requiredPropertyConstant}, P)
\end{split}
\end{equation*} \(\)
\begin{equation*}
\begin{split}
c_2 = &\text{statement\_EDB}(Q, R, \text{propertyConstant}, I) \wedge{} \\
&\text{statement\_EDB}(S, I, \text{requiredPropertyConstant}, V) \wedge \text{unequal}(\{A\}, V)
\end{split}
\end{equation*}
The final violation rule would then be:
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{} \\
&\text{statement\_EDB}(O, V, P, X) \wedge \text{last}(O, V) \wedge{} \\
&\text{require}(O, \text{propertyConstant}, \text{requiredPropertyConstant})
\end{split}
\end{equation*}

\subsection{Inverse (Q21510855)}
The inverse constraint is similar to the value requires statement constraint in requiring a statement on a constrained value with a specific property. However, instead of putting no constraint or a list of fixed values on the required statements value it set a relative requirement: the constrained item, meaning \(t = R\). The pre-processing and inequalities thus remain the same, but the conjunctions change to 
\begin{equation*}
\begin{split}
c_1 = &\text{statement\_EDB}(Q, R, \text{propertyConstant}, I) \wedge{} \\
&\text{statement\_EDB}(S, I, P, V) \wedge{} \\
&\text{unequal}(\text{inversePropertyConstant}, P)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
c_2 = &\text{statement\_EDB}(Q, R, \text{propertyConstant}, I) \wedge{} \\
&\text{statement\_EDB}(S, I, \text{inversePropertyConstant}, V) \wedge{} \\
&\text{unequal}(R, V)
\end{split}
\end{equation*}

\subsection{Symmetric (Q21510862)}
The symmetric constraint can be translated exactly as the inverse constraint if the inverse property where set to the same as the constrained property.

\subsection{Multi-value (Q21510857)}
The multi-value constraint requires a limited count of constrained statements. Alternatively, it could be said that if the item requires a second statement, the constraint is violated. Pre-processing extracts all items statements and inequality between all item statement properties as usual and the conjunction is 
\begin{equation*}
\begin{split}
c = &\text{statement\_EDB}(Q, I, \text{propertyConstant}, X) \wedge{} \\
&\text{statement\_EDB}(S, I, P, V) \wedge \text{unequal}(\text{propertyConstant}, P)
\end{split}
\end{equation*}
The predicate require\_second\([2]\) is introduced with the same meaning as require except that it will be applied after a required property has been found:
\begin{equation*}
\begin{split}
\text{require\_second}&(S, \text{propertyConstant}, \text{propertyConstant}) \leftarrow \\
&\text{next}(R, S) \wedge \text{statement\_EDB}(R, I, \text{propertyConstant}, C) \wedge{} \\
&\text{next}(Q, R) \wedge \text{require}(Q, \text{propertyConstant}, \text{propertyConstant})  \wedge c
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{require\_second}&(S, \text{propertyConstant}, \text{propertyConstant}) \leftarrow \text{next}(R, S) \wedge{} \\
&\text{require\_second}(R, \text{propertyConstant}, \text{propertyConstant}) \wedge c
\end{split}
\end{equation*}
A violations would be any last statement requiring a second constrained statement.\\

\subsection{Single value (Q19474404)}\label{subsec_3_single_value}
The single value constraint can be divided into two different cases, depending on if the set of separators \(S\) is empty or not. Pre-processing needs to extract all item statements and their qualifiers and establish inequality between all statement IDs and all qualifier values.

\subsubsection{No separators}
If the separator set is empty, the violation simply occurs if there are two constrained statements on the same item. 
\begin{equation}\label{eq_no_separators_triple}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{} \\
&\text{statement\_EDB}(O, I, \text{propertyConstant}, X) \wedge{} \\
&\text{unequal}(S, O)
\end{split}
\end{equation}
For qualifiers and reference there is no ID whose inequality could be checked. However, since the statement ID and the property of a possible conflict are always the same, inequality can be tested on the values.
\begin{equation*}
\begin{split}
\text{violation\_qualifier}&(S, \text{propertyConstant}, V) \leftarrow \\
&\text{qualifier\_EDB}(S, \text{propertyConstant}, V) \wedge{} \\
&\text{qualifier\_EDB}(S, \text{propertyConstant}, X) \wedge{} \\
&\text{unequal}(V, X)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_reference}&(S, \text{propertyConstant}, V) \leftarrow \\
&\text{reference\_EDB}(S, H, \text{propertyConstant}, V) \wedge{} \\
&\text{reference\_EDB}(S, J, \text{propertyConstant}, X) \wedge{} \\
&\text{unequal}(V, X)
\end{split}
\end{equation*}
\todo{Check if all reference-rules look exactly like the qualifier rules and cut them out if it is so.}

\subsubsection{With separators}\label{subsubsec_with_separators}
To find all violations under separators a number of things have to be considered. Only triples are eligible, since qualifiers cannot have further qualifier, and the order of qualifiers on constrained statements needs to be pre-processed as well since qualifier non-existence is relevant. The pattern needs to be applied for every separator, meaning the conjunction is
\begin{equation*}
c = \text{statement\_EDB}(S, I, \text{propertyConstant}, C) \wedge \text{qualifier\_EDB}(S, P, V) \wedge \text{unequal}(P, \text{separatorConstant})
\end{equation*}
for each separator in \(S\).\\

With qualifier non-existence established the violation can be found. Two statements form a violation if they are distinct as per equation \ref{eq_no_separators_triple} and additionally fulfil the condition that all qualifiers are either equal or non-existent. \(\forall X \subset S, Y = S \setminus X\) the following rule has to be added. Note that \(\text{predicate}(\{X\})\) denotes one atom for each element \(x \in X\) as introduced in section \ref{subsec_3_allowed_units}. With the predicate does\_not\_have\([2]\) linking a statement ID to the separator it does not have via 
\begin{equation*}
\begin{split}
\text{does\_not\_have}(S, R) \leftarrow &\text{statement\_EDB}(S, I, \text{propertyConstant}, C) \wedge{} \\
&\text{last\_qualifier}(S, P, V) \wedge \text{require}(S, P, V, \text{propertyConstant}, R)
\end{split}
\end{equation*}
and the predicate has\_same[2] linking two statement IDs to the separator for which the values are the same via
\begin{equation*}
\begin{split}
\text{has\_same}(S, O, Q) \leftarrow &\text{statement\_EDB}(S, I, \text{propertyConstant}, C) \wedge{} \\
&\text{statement\_EDB}(O, I, \text{propertyConstant}, X) \wedge{} \\
&\text{qualifier\_EDB}(S, Q, V) \wedge \text{qualifier\_EDB}(O, Q, V)
\end{split}
\end{equation*}
 for brevity the rules are
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{} \\
&\text{statement\_EDB}(O, I, \text{propertyConstant}, C) \wedge{} \\
&\text{unequal}(S, O) \wedge{} \\
&\text{has\_same}(S, O, \{X\}) \wedge{} \\
&\text{does\_not\_have}(S, \{Y\}) \wedge{} \\
&\text{does\_not\_have}(O, \{Y\})
\end{split}
\end{equation*}

\subsection{Mandatory qualifier (Q21510856)}
The mandatory qualifier constraint needs to determine qualifier non-existence on constrained statements to find violations, which is similar to section \ref{subsubsec_with_separators}. All constrained statements and their qualifiers have to be extracted and the order of the qualifiers pre-processed. Inequality must be established between all qualifier properties and the conjunction is 
\begin{equation*}
\begin{split}
c = &\text{statement\_EDB}(S, I, \text{propertyConstant}, C) \wedge{} \\
&\text{qualifier\_EDB}(S, P, V) \wedge \text{unequal}(P, \text{requiredPropertyConstant})
\end{split}
\end{equation*}
With the usual require-pattern for qualifiers and the does\_not\_have rule added for brevity the violations would be
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge \text{does\_not\_have}(S, \text{requiredPropertyConstant})
\end{split}
\end{equation*}

\subsection{Single best value (Q52060874)}
The single best value constraint, like the single value constraint (section \ref{subsec_3_single_value}), differentiates between the set of separators \(S\) being empty or not. Since the constraint depends on the rank of statements this needs to be extracted during pre-processing and attached to the statement ID with the new predicate rank\([2]\). Qualifiers and references are not affected since they do not have ranks. For this constraint all item statements, their rank and their qualifiers need to be extracted and inequality established between the statement IDs and the qualifier values.\\

\subsubsection{No separators}
If the separator set is empty, the violation simply occurs if there are two constrained statements on the same item with the preferred rank. Thus the equation \ref{eq_no_separators_triple} is expanded to
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{} \\
&&\text{rank\_EDB}(S, \text{preferredRankConstant}) \wedge{} \\
&\text{statement\_EDB}(O, I, \text{propertyConstant}, X) \wedge{} \\
&&\text{rank\_EDB}(O, \text{preferredRankConstant}) \wedge{} \\
&\text{unequal}(S, O)
\end{split}
\end{equation*}

\subsubsection{With separators}
As in the case above, the qualifier non-existence and violation rules are very similar to single value. The only change is the addition of the rank requirements as shown below.
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{statement\_EDB}(S, I, \text{propertyConstant}, V) \wedge{} \\
&&\text{rank\_EDB}(S, \text{preferredRankConstant}) \wedge{} \\
&\text{statement\_EDB}(O, I, \text{propertyConstant}, W) \wedge{} \\
&&\text{rank\_EDB}(O, \text{preferredRankConstant}) \wedge{} \\
&\text{unequal}(S, O) \wedge{} \\
&\text{has\_same}(S, O, \{X\}) \wedge{} \\
&\text{does\_not\_have}(S, \{Y\}) \wedge{} \\
&\text{does\_not\_have}(O, \{Y\})
\end{split}
\end{equation*}

\subsection{Type (Q21503250)}
\todo[inline]{Well. I wouldn't know. I'd have to expand the require pattern to search up the subclass tree and if require arrives at the root the class is not there. But a) its not a tree, so that does not work and b) there is no single root.\\
Alternatively I could compute each items class via transitivity aaaand.... well. Violation if items classes unequal required class, but how to write that? Well, maybe I'll get a brilliant idea. Or I'll stop being stupid in case this does not require a brilliant idea.}

\subsection{Value type (Q21510865)}
\todo[]{as above, so below. no wait...}

\chapter{Evaluation/Comparison}

\section{Inequality evaluation}\label{sec_inequality_evaluation}
\end{document}
