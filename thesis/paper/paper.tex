\documentclass[hyperref,bachelorofscience,fleqn]{cgvpub}
%weitere Optionen zum Ergänzen (in eckigen Klammern):
% 
% bibnum	numerische Literaturschlüssel
% final 	für Abgabe	
% lof			Abbildungsverzeichis
% lot			Tabellenverzeichnis
% noproblem	keine Aufgabenstellung
% notoc			kein Inhaltsverzeichnis
% twoside		zweiseitig
\author{Adrian Bielefeldt}
\title{Title}
\birthday{15. October 1994}
\placeofbirth{Dresden}
\matno{3694323}
\betreuer{Prof. Dr. Markus Krötzsch}
\bibfiles{literatur}
\problem{problem}
\copyrighterklaerung{copyright stuff}
\acknowledgments{Acknowledgements}
\abstracten{abstract text English}

\usepackage{rotating}
\usepackage{float}
\restylefloat{table}
\usepackage{makecell}
\renewcommand{\cellalign}{tl}
\usepackage{tabularx}
\usepackage{todonotes}
\usepackage{adjustbox}

\begin{document}
\chapter{Introduction/Preliminaries}
Motivation
\newpage
\section{Wikidata}
Wikidata is the knowledge base sister project of Wikipedia. It is a public, open database system that, at its core, stores statements about specific items. The basic unit of information is a triple subject-predicate-object stating an item (subject) has a property (predicate) which is either another item or a value of some kind (object). These store the relations of entities with each other or with specific data. An entity is either an item, which represents a topic, concept or real world entity, or a property, which denotes a relation an item has to another or with a value. They have numeric identifiers that are prefixed with Q and P respectively. A value is one of several data types noted in table \ref{tab_datatypes}, although it is also possible to use none or some as values for statements that have no value (akin to negation) or have a currently unknown value. Every property determines the data type it accepts as an object. \\

\begin{table}[H]
\caption{wikidata data types}\label{tab_datatypes}
\begin{tabularx}{\textwidth}{lllX}
Data type & Fields & Description \\
\hline
string & string (string) & simple string literal \\
globecoordinate & \makecell{latitude (float) \\ longitude (float) \\ precision (float) \\ globe(URI)} & \makecell{coordinates on a given celestial body \\ or geographic standard} \\
quantity & \makecell {amount (decimal) \\ upperBound (decimal) \\ lowerBound (decimal) \\ unit (URI or 1)} & \makecell{quantity of a specified unit (or none) \\ with uncertainty} \\
time & \makecell {time (string) \\ calendarmodel (URI) \\ precision (integer)} & \makecell {time as a string according to calendarmodel \\ (julian or gregorian),\\ with precision mapping to orders of magnitude \\ (e.g.. 10 years, months)} \\
\end{tabularx}
\end{table}

While this is similar to RDF and Wikidata has in fact been exported as RDF \cite{EGKMV2014}, the data structure is more complex than simple triples. It allows, to store additional information about statements. This is done via a statement ID, which is assigned to every triple storing information about an item. Every statement can be references by qualifiers and references which contain a predicate and an object, but have no item as subject but instead the statement ID. Qualifiers provide contextual information for statements. The most common context is the time frame in which the statement was accurate, e.g. stating the start and end times of a head of state, but other information is possible, e.g. determination method for measurements or the elevation above sea level for the highest point. References are information that supports the claim by citing the source and possibly additional information like when it was retrieved or when the source was published.

Other information regarding items like labels and descriptions in different languages as well as aliases and site links to other Wikimedia projects are also part of the data model but are not subject to constraints and are thus not explored further.
\section{Datalog}
Datalog is a logic programming language. It is fully declarative and uses simple rules to derive additional knowledge from given facts. The most basic unit of information in datalog is a \emph{constant}, which will be denoted as someConstant. In the context of Wikidata any item or property, e.g. Earth (Q2) or head of government (P6), could be represented as a constant. Relations in datalog are expressed as \emph{predicates} with a specified arity \(n\), written as predicate\([n]\). To stay close to Wikidata in our examples let us take the predicate statement\([3]\) as an example. This would be used to express the \emph{item}-\emph{property}-\emph{value} relation with each position representing one part of the triple.\\
Additionally, datalog also knows \emph{variables}, which will be capitalized like \(X\). Constants and variables are collectively known as \emph{terms} and are, together with predicates, used to form \emph{atoms}. An atom has the form predicate\((t_1, \ldots , t_n)\) with \(n\) as the arity of the predicate and \(t_1,\ldots,t_n\) terms.\\
Atoms are the building blocks of \emph{rules}, which are used to derive information in datalog. Given atoms \(C\) and \(B_n\), a rule takes the form \(C \leftarrow P_1 \wedge \ldots \wedge P_m\), with \(C\) being the conclusion and \(B_1 \wedge \ldots \wedge B_m\) the premise. If the premise does not contain any atoms such a rule is called a \emph{fact}, or a \emph{ground rule} if it additionally only uses constants. A finite set of rules forms a \emph{program}.\\

Within the rule predicates we can differentiate between two different schemas: the \emph{extensional schema} and the \emph{intensional schema}, called EDB and IDB \todo{Shouldn't this be called \\EDP/IDP?} (extensional/intensional database predicate). An EDB may only occur in the premise of a rule, meaning it can never be derived. All others (predicates that appear in the conclusion at least once) are IDB.

\todo[inline]{Explain the relation to FO-logic?}

For the following example taken from Wikidata descriptive names will be used instead of the IDs to increase readability. The individual entities and properties are introduced with their ID beforehand so the example can be retraced. The blue whales (Q42196) parent taxon (P171) is balaenoptera (Q133320), which in turn has the parent taxon rorqual (Q232829). The predicates used are tripleEDB\([3]\) as the input and isInTaxonIDB\([2]\), which will be derived. The basic facts are:\\
\[\text{tripleEDB}(\text{blue whale}, \text{parent taxon}, \text{balaenoptera})\]
\[\text{tripleEDB}(\text{balaenoptera}, \text{parent taxon}, \text{rorqual})\]
From this we can draw conclusions. The first step is to represent the already existing facts as IDB:
\[\text{isInTaxonIDB}(X, Y) \leftarrow \text{tripleEDB}(X, \text{parent taxon}, Y)\]
Finally the transitive closure of this relation can be derived with
\[\text{isInTaxonIDB}(X, Y) \leftarrow \text{isInTaxonIDB}(X, Z) \wedge \text{isInTaxonIDB}(Z, Y)\]

\todo[inline]{Probably a good place to explain existential and universal quantifiers.}
\section{Representation}
To model the basic representation of triples, qualifiers and references three predicates are introduced.\\
tripleEDB\([4]\) represents a single statement consisting of the statement ID, the item ID, the property ID and the value as either and item ID or a string-representation of the data value.\\
qualifierEDB\([3]\) and referenceEDB\([3]\) represent the qualifiers and references on a given statement ID with their respective property id and the value as usual.\\

Additional predicates modelling different pre-processing steps are explained in chapter \ref{cha_rules}.
\section{Terminology}
\begin{table}[H]
\caption{abbreviations}
\begin{tabular}{ll}
Shorthand & Description \\
\hline
constrained statement & statement with the constrained property as predicate \\
constrained qualifier & qualifier with the constrained property as predicate \\
constrained reference & reference with the constrained property as predicate \\
constrained item & item with a constrained statement \\
item statement & statement on the same item as the constrained statement \\
\end{tabular}
\end{table}
\chapter{Property Constraints}

To improve the data quality, help editors avoid common mistakes and clarify the usage of properties, Wikidata allows constraints to be defined on properties. They are however not firm rules and exceptions can and should be made if necessary. A property constraint says something about the way a property may or may not be used. This can mean simple restrictions on the statement a property is part of, e.g. only certain values are allowed or more complex requirements on connected parts of the data graph, e.g. the value of a statement with this property should have certain statements. Further down you can find table \ref{tab_property_constraints}, which list the existing property constraints. Afterwards the constraints will be explained in detail and either a basic approach for their modelling or reasoning why it is not possible or sensible to model it given.\\

To apply a constraint to a property a statement <property> <P2302> <constraint> is added to the properties item page, where <property> is the property that should be constrained, <P2302> (property constraint) denotes that the property has a constraint and <constraint> is the specific constraint. Note that a constrained statement means a statement whose predicate is a property that has a specific constraint. A simple example for this would be distinct values (Q21502410) stating that values of the property must be unique across all constrained statements. For this case no additional information regarding the constraint is necessary and violation could be found by surveying all constrained statements and comparing their values.\\
Constraints can be further specified by using qualifiers on the constraint statement. These qualifiers are either optional or mandatory and may be applied once or multiple times. For example, the none of constraint (Q52558054) states that values for a specific property may not be in a set of disallowed values. These are specified as qualifiers using item of property constraint (P2305) on the constraint statement and require at least one such statement.\\
More complex dependencies are also possible. A constraint can depend on all constrained statements of a specific item (single value constraint [Q19474404]), on all statements of the value of a constrained statement (value requires statement constraint [Q21510864]) or in the most complex case on all statements using the subclassOf-predicate (type constraint [Q21503250]).

Table \ref{tab_property_constraints} shows all currently used property constrains in Wikidata. It is sorted by difficulty, which is an estimate of the necessary pre-processing and rule complexity based on required features. These required features are conditions that cannot natively be expressed in datalog and would require some kind of pre-processing to be made available. Difficulty 0 does not need any pre-processing except for loading the data into datalog as ground rules. 1 requires inequality, which can be easily solved with brute force but will be improved in chapter \ref{cha_rules}. 2 needs negation in a form that can be solved without pre-processing everything and 3 in a form that would require all logic as part of pre-processing. Other features needed for category three are regular expressions, which could theoretically be translated but would require large amounts of pre-processing, value comparison, general negation and finally web requests to test if a link is valid.

\begin{table}[H]
\caption{property constraints}\label{tab_property_constraints}
\begin{tabularx}{\textheight}{rrllllX}
Difficulty & \makecell{\# constrained\\ properties} & Identifier & Name & Required Features \\
\hline
0 & 1410 & Q53869507 & Scope &  \\
0 & 781 & Q21502838 & Conflicts with &  \\
0 & 27 & Q52004125 & Allowed entity types &  \\
0 & 17 & Q52558054 & None of &  \\
1 & 2843 & Q21502410 & Distinct value & Inequality \\
1 & 343 & Q21514353 & Allowed units & Inequality \\
1 & 303 & Q21510851 & Allowed qualifiers & Inequality \\
1 & 116 & Q21510859 & One of & Inequality \\
1 & 3 & Q52060874 & Single best value & Inequality \\
1 & 1 & Q52712340 & One-of qualifier value & Inequality \\
2 & 4265 & Q21503247 & Item requires statement & Negation (statement non-existence) \\
2 & 244 & Q21510864 & Value requires statement & Negation (statement non-existence) \\
2 & 119 & Q21510855 & Inverse & Negation (statement non-existence) \\
2 & 33 & Q21510862 & Symmetric & Negation (statement non-existence) \\
2 & 13 & Q21510857 & Multi-value & Negation, Count (up to two) \\
2 & 2909 & Q19474404 & Single value & Inequality, partially negation (qualifier non-existence) \\
2 & 203 & Q21510856 & Mandatory qualifier & Negation (qualifier non-existence) \\
3 & 2613 & Q21503250 & Type & Negation (derived fact negation) \\
3 & 707 & Q21510865 & Value type & Negation (derived fact negation) \\
3 & 3021 & Q21502404 & Format & Regular expressions \\
3 & 188 & Q21510860 & Range & Value comparison \\
3 & 106 & Q52848401 & Integer & Regular expressions \\
3 & 65 & Q51723761 & No bounds & Negation \\
3 & 53 & Q21510852 & Commons link & Web request \\
3 & 10 & Q54554025 & Link & Negation \\
3 & 6 & Q21510854 & Difference within range & Value comparison \\
3 & 1 & Q25796498 & Contemporary constraint & Negation \\
\end{tabularx}
\end{table}


\section{Wikidata constraints explained}
This section will explain all interesting, meaning translatable or partially translatable, currently used property constraints on Wikidata. They will be presented roughly in descending order of the number of properties with this constraint, although constraints with similar function will be explained directly after one another. Also, all constraints that were considered untranslatable are listed at the and, each with a short explanation as to why they were placed in that group.\\

Every constraint will start with a table showing basic properties of the constraint. This includes the requirement, relevant qualifiers, possible violations of the constraint and the data the constraint depends on. The requirement states which part of the data graph in relation to the constrained statement are restricted or need to exist. The qualifiers list their cardinality, meaning if they are required and if they may be used multiple times, and a short description. The violations list the conflicting (part of a) statement in relation to the constrained statement. The dependencies list their relation to the constrained statement. Table \ref{tab_example_constraint} shows the formatting as an example.

\begin{table}[H]
\caption{example constraint (Q31415926)}\label{tab_example_constraint}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & requirement \\
\hline
Qualifiers & \makecell{example qualifier (P1234) -- 1..* \\ description \\ another qualifier (P4321) -- 0..1 \\ different description} \\
\hline
Violation & \makecell{one way to violate the constraint \\ another violation possibility} \\
\hline
Dependency & statements, qualifiers or references in relation to the constrained statement\\
\hline
Rule features & features needed (missing if no features needed) \\
\hline
\end{tabularx}
\end{table}

\subsection{Property scope (Q53869507)}
The property scope constraint specifies if a property may be used in a statement, qualifier or reference as predicate.
\begin{table}[H]
\caption{property scope constraint (Q53869507)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement \\
\hline
Qualifiers & \makecell{property scope (P5314) -- 1..3 \\ must be as main value (Q54828448), as qualifier (Q54828449) or as reference (Q54828450) \\ specifies allowed use in statements, qualifiers or references} \\
\hline
Violation & constrained statement in a position that is not allowed \\
\hline
Dependency & constrained statement, qualifier or reference \\
\hline
\end{tabularx}
\end{table}

Since only three possibilities exist, this is equivalent to forbidding all other possibilities and the rules are simple mapping all of tripleEDB, qualifierEDB and referenceEDB with the constrained property that are not allowed.

\subsection{Conflicts-with (Q21502838)}
The conflicts with constraint forbids either certain statements or statements with a specific property on constrained items.
\begin{table}[H]
\caption{Conflicts-with constraint (Q21502838)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & item statement \\
\hline
Qualifiers & \makecell{conflicting property (P2306) -- 1 \\ property no item statement may have (with conflicting values if specified) \\
conflicting values (P2305) -- 0..* \\ values that may not appear in item statements with the conflicting property} \\
\hline
Violation & \makecell{item statement with the conflicting property \\ item statement with the conflicting property and one of the conflicting values} \\
\hline
Dependency & all item statements \\
\hline
\end{tabularx}
\end{table}
The rule modelling can simply be done by choosing all tripleEDB with the constrained property and then all tripleEDB on the same item with the conflicting property, specifying the values as well if necessary.

\subsection{Allowed entity types (Q52004125)}
The allowed entity types constraint limits if a property may be used on an item, a property or a lexeme, although lexemes are not yet deployed.

\begin{table}[H]
\caption{Allowed entity types constraint (Q52004125)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement \\
\hline
Qualifiers & \makecell{allowed entity type (P2305) -- 1..3 \\ must be wikibase item (Q29934200), wikibase property (Q29934218) \\ or lexeme (Q51885771); \\ specifies the type the property may be used on} \\
\hline
Violation & \makecell{constrained statement on an entity of a type unequal to all allowed types} \\
\hline
Dependency & constrained statement and entity type of the subject \\
\hline
\end{tabularx}
\end{table}

Since there are only three options (and only two in use), violations can be found without inequality by finding the tripleEDB with the constrained property whose subject is of the type that is not allowed, meaning either wikibase item or wikibase property.

\subsection{None of (Q52558054)}
The none of constraint restricts the values that the property may refer to by listing a set of values as forbidden.

\begin{table}[H]
\caption{None of constraint (Q52558054)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement \\
\hline
Qualifiers & \makecell{forbidden value (P2305) -- 1..* \\ values that may not appear in a constrained property} \\
\hline
Violation & \makecell{constrained statement with a forbidden value} \\
\hline
Dependency & constrained statement \\
\hline
\end{tabularx}
\end{table}

Modelling this constraint is very straightforward, since each forbidden value forms a property-value pair with the constrained statement that may not exists. Thus a violations is a tripleEDB with the constrained statement and a forbidden value.

\subsection{Distinct values (Q21502410)}
The distinct values constraint forbids the existence of two constrained statements with the same value.
\begin{table}[H]
\caption{distinct values constraint (Q21502410)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement value \\
\hline
Violations & two constrained statements with same value \\
\hline
Dependency & all constrained statements\\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}
To model the distinct values constraint it is necessary to find triples tripleEDB with the constrained property and the same value whose statement id is unequal.

\subsection{Allowed units (Q21514353)}
The allowed units constraint specifies that a constrained statement may only have a unit that is in a set of specific units.

\begin{table}[H]
\caption{Allowed units constraint (Q21514353)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement unit \\
\hline
Qualifiers & \makecell{allowed unit (P2305) -- 1..* \\ units that the statement may have (or none for dimensionless units)} \\
\hline
Violation & \makecell{constrained statement with a unit unequal to all allowed units} \\
\hline
Dependency & constrained statement and its unit \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

Modelling the constraint requires a predicate associating the value or the statement with its unit and inequality between every unit and all allowed units. Then a violation can be found by finding all tripleEDB with the constrained property and a unit unequal to all allowed units.

\subsection{Allowed qualifiers (Q21510851)}
The allowed qualifiers constraint specifies that only a limited set of properties may be used as qualifiers on a constrained statement.

\begin{table}[H]
\caption{Allowed qualifiers constraint (Q21510851)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & qualifier on constrained statement \\
\hline
Qualifiers & \makecell{	allowed qualifier (P2306) -- 1..* \\ qualifiers that the statement may have} \\
\hline
Violation & \makecell{constrained statement with a qualifier unequal to all allowed qualifiers} \\
\hline
Dependency & constrained statement and its qualifiers \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

To represent a violation of this constraint in datalog inequality between all specified allowed qualifiers and the properties of the qualifiers on constrained statements is required. A tripleEDB with the constrained property and a qualifierEDB on that statement with a property different from all allowed qualifiers would violate the constraint.

\subsection{One-of (Q21510859)}
The one-of constraint limits the values a property may use to a set of given values.

\begin{table}[H]
\caption{One-of constraint (Q21510859)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement \\
\hline
Qualifiers & \makecell{allowed values (P2305) -- 1..* \\ values that may be used in the constrained statement} \\
\hline
Violation & \makecell{constrained statement with a value unequal to all allowed values} \\
\hline
Dependency & constrained statement \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

Modelling the one-of constraint requires a rule finding a tripleEDB with the constrained property whose value is unequal to all allowed values, meaning the inequality between each value of constrained statements and all allowed values must be given.

\subsection{Single best value (Q52060874)}
The single best value constraint requires that only one constrained statement per item has the rank preferred.

\begin{table}[H]
\caption{Single best value constraint (Q52060874)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & item statement rank \\
\hline
Violation & \makecell{items with two constrained statements with rank preferred} \\
\hline
Dependency & all item statements and their rank \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

Modelling the constraint means a count of all constrained statements with rank preferred is necessary, with a violation constituted if an item has a count of two or higher. Since it is only needed to differentiate between one and many, the rules could be written explicitly.

\subsection{One-of qualifier value (Q52712340)}
The one-of qualifier value constraint restricts which values may be used on a qualifier with a given property on a constrained statement.

\begin{table}[H]
\caption{One-of qualifier value constraint (Q52712340)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement qualifier value \\
\hline
Qualifiers: & \makecell{qualifier property (P2306) -- 1 \\ property of the restricted qualifier\\
qualifier values (P2305) -- 1..* \\ values the qualifiers may take}\\
\hline
Violation & \makecell{constrained statement with a qualifier with the qualifier property and a value unequal to all qualifier values} \\
\hline
Dependency & constrained item and qualifiers with the qualifier property \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

The constraint can be modelled if the inequality between a value of a qualifier property with all qualifier values is given. The violations could then be found by taking a tripleEDB with the constrained property and a qualifier with the qualifier property on the former statement whose value is unequal to all qualifier values.

\subsection{Item requires statement (Q21503247)}\label{subsec_item_requires_statement}
The item requires statement constraint requires an additional statement on an item with a statement using the constrained property, possibly also using a specific value from the list of allowed values.
\begin{table}[H]
\caption{item requires statement constraint (Q21503247)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & item statement \\
\hline
Qualifiers & \makecell{required property (P2306) -- 1 \\ property the item statement must have \\ allowed value (P2305) -- 0..* \\ values the item statement may have} \\
\hline
Violation & \makecell{no item statement with required property \\ all item statements with required property have no allowed value} \\
\hline
Dependency &  all item statements\\
\hline
Rule features & negation \\
\hline
\end{tabularx}
\end{table}

An item violates the constraint if it a) has a statement using constrained property as predicate, b1) has no statement using the required property as predicate, or (if allowed values are specified) b2) has only statement using required property as predicate that do not use one of the allowed values as value.\\
While condition a) can easily be tested by a tripleEDB-atom with the constrained property, condition b1) and b2) pose the question if an item does not have a statement. This is addressed in section [?].

\subsection{Value requires statement (Q21510864)}\label{subsec_value_requires_statement}
The value requires statement constraint requires an additional statement on the value of constrained statement, possibly also using a specific value from the list of allowed values. Since the constraint works very similar to item requires statement (see \ref{subsec_item_requires_statement}) --- requiring a statement on the value of the constrained statement instead of on the item --- it is not elaborated on.

\subsection{Inverse (Q21510855)}\label{subsec_inverse}
The inverse constraint requires an additional statement on the value of a constrained statement with a specific property and the constrained item as value. It is very similar to value requires statement (see \ref{subsec_value_requires_statement}), although it does not specify allowed values, since the required statement has one specific value: the constrained item. While this means it could not be modelled exactly as a value requires statement constraint, it would only require very small rule changes and will thus not be elaborated on.

\subsection{Symmetric (Q21510862)}
The symmetric constraint requires an additional statement on the value of a constrained statement with the constrained property and the constrained item as value. It is thus equal to an inverse constraint (see \ref{subsec_inverse}) with the same property as constrained property and required property and will not be elaborated on.

\subsection{Multi-value (Q21510857)}
The multi-value constraint specifies that the constrained property should appear in multiple statements of an item or none.

\begin{table}[H]
\caption{Multi-value constraint (Q21510857)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & item statement \\
\hline
Violation & \makecell{constrained item with exactly one constrained statement} \\
\hline
Dependency & all item statements \\
\hline
Rule features & count \\
\hline
\end{tabularx}
\end{table}

To model this constraint a count of statements using the constrained property per item would be needed. Then a violation would be any constrained item with a count of one for the constrained property. Since there is no need for arbitrarily large counts, but only for the difference between one and two, this could be solved explicitly.

\subsection{Single value (Q19474404)}
The single value constraint constrains the values a property may take on a single item. A property marked with the single value constraint can have properties marked as separators, which define exceptions under specific circumstances.
\begin{table}[H]
\caption{single value constraint (Q19474404)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement value \\
\hline
Qualifiers & \makecell{separator (P4155) -- 0..* \\ qualifiers that must be different for exception} \\
\hline
Violation & \makecell{two constrained statements with same item and value \\ (exception: statements with separators as qualifiers with different values)} \\
\hline
Dependency & \makecell{without separators: all constrained statements on one item \\ with separators: additionally all qualifiers with separators on those statements }\\
\hline
Rule features & inequality, partially negation \\
\hline
\end{tabularx}
\end{table}

If no separators are specified, two triple form a violation of this constraint if they a) belong to the same item, b) have the same constrained property, and c) have the same value.
If separators are specified, a violation as above can be ignored if the statements each have at least one qualifier with the same separator as predicate and different values.\\
In the case without separators the modelling idea would be to find two triples tripleEDB with the same item and constrained property and test if their id is unequal. If separators were specified a violation would be the two triples and all their separator qualifiers either equal or non-existent.

\subsection{Mandatory qualifier (Q21510856)}
The mandatory qualifier constraint requires that a constrained statement has a qualifier with a specific property.

\begin{table}[H]
\caption{Mandatory qualifier constraint (Q21510856)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & qualifier on constrained statement \\
\hline
Qualifiers & \makecell{required property (P2306) -- 1 \\ qualifier that the statement must have} \\
\hline
Violation & \makecell{constrained statement without a qualifier with the required property} \\
\hline
Dependency & constrained statement and its qualifiers \\
\hline
Rule features & negation \\
\hline
\end{tabularx}
\end{table}

To find violations of this constraint one would find a tripleEDB with the constrained property, but where no qualifierEDB for the statement and with the required property exists.

\subsection{Type (Q21503250)}\label{subsec_type}
The type constraint requires the existence of either one of a specific statement (instanceOf <class>) or a chain of statements using subclassOf to connect directly (subclassOf* <class>)
or via instanceOf (instanceOf/subclassOf* <class>) for all classes on the constrained item.
\begin{table}[H]
\caption{type constraint (Q21503250)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & chain of statements \\
\hline
Qualifiers & \makecell{relation (P2309) -- 1 \\ must be instance of (Q21503252), subclass of (Q21514624), \\ or instance or subclass of (Q30208840); \\ specifies the relation the constrained item must have to the classes\\
class (P2308) -- 1..* \\ entities that must be reached using the relation} \\
\hline
Violation & constrained item without relation to a class \\
\hline
Dependency & \makecell{statements of constrained items using instanceOf (P31) or subclassOf(P279) \\ all statements using subclassOf (P279) }\\
\hline
Rule features & inequality, negation \\
\hline
\end{tabularx}
\end{table}

If the relation is instanceOf, the constraint can be evaluated like multiple item requires statement constraints (see \ref{subsec_item_requires_statement}) by setting the required property to instanceOf (P31) and, for each created item requires statement constraint, the allowed value to one of the classes. \\
For the relations involving subclasses all transitive subclass relationships would be concluded by setting a subclass relationship if a third item can be found that is subclass of one and subclassed by the other item. This would be extended with one step of instanceOf. A violation would then be any constrained item that is not subclass of any of the classes.

\subsection{Value type (Q21510865)}
The value type constraint works like the type constraint (see \ref{subsec_type}) except the statement chains are required on the value of the constrained statement instead of the constrained item. It will thus not be expanded upon.

\section{Reasoning for unconsidered constraints}
Multiple constraints have not been described above for different reasons. The most prominent of these is the format constraint (Q21502404) which specifies a regular expressions the values of the constrained property must adhere to. Evaluating these expressions would be theoretically possible but \\
a) primarily results in a large amount of preprocessing and\\
b) does not solve the question of negation, since violations would be values that do not conform to their required regular expression. \\

The integer constraint (Q52848401), which requires values of a constrained property be integers (notably a quantity without decimal places), could easily be seen as a specific format constraint. While precomputing if a value is an integer or not could be done, it would mean that no actually relevant rules would be needed for the evaluation in datalog. \\

Another problem that could not be sensibly solved is the comparison of values, needed for range (Q21510860), difference within range (Q21510854) and contemporary constraint (Q25796498). Range restricts the values of a constrained property within a certain range, difference within range specifies that two item statements should have values within a certain range and contemporary constraint specifies that subject and object of a constrained statement have to have coexisted at some point in time. While it would be possible to extract all values that might need to be compared and precompute the comparison, it would make most of the work precomputing and leave little to be done in datalog.\\

Link constraint (Q54554025), requiring that constraint statements must have one or more references, requires a negation that cannot be concluded except by explicitly precomputing it, which makes the evaluation unnecessary. \\
A similar situation is the no bounds constraint (Q51723761), which requires that quantity values have neither upper nor lower bound. While it would be possible to precompute if a statement has no upper or lower bound, this would shift basically all evaluation logic into precomputing.

And finally commons link constraint (Q21510852) requires that values for a property should be valid links to to Wikimedia Commons. This validity cannot be testes from within datalog since there is no way to query the web for information.


\chapter{Rules}\label{cha_rules}
The previous chapter has show that most constraints cannot be modelled without at least some amount of preprocessing. Only Scope, Conflicts with, Allowed entity types and None of can be modelled directly. This is due to the fact that Conflicts with and None of exclude a limited and specified set of statements from validity and these cases can thus be directly takes as violations. Scope and Allowed entity types work very similar, since there are only three respectively two possible values and violations are simply the options that have not been allowed.  The rules for these constraints are described in section \ref{sec_no_preprocessing}.\\

A problem that occurs multiple times is the need to determine inequality between constants. Distinct value, Allowed units, Allowed qualifiers, One of, Single best value and One-of qualifier value each require a rule to determine if a value, unit or property is not equal to another. To this end a certain amount of preprocessing is necessary, most notably the extraction of all constant pairs whose inequality has to be determined for finding the violations. To avoid putting and undue amount of processing outside of datalog this extraction will not check more than that the constant is in the right position relative to the constrained statement, e.g. all values on statements constrained by Distinct value or all qualifiers on statements constrained by Allowed qualifiers. From this set inequality will be generated, different versions of which will be introduced in section \ref{sec_inequality} and evaluated with regards to their performance in section \ref{sec_inequality_evaluation}.\\

Negation as a general problem cannot be solved in datalog. One could pre-process every necessary fact to be negated and add this to the ground facts, but this is not the purpose of this work. However, not all constraints require a general negation. Item requires statement, Value requires statement, Inverse and Symmetric are all violated if a statement does not exist on a specific item. This problem can be solved with limited amounts of preprocessing by leveraging a preprocessed statement order per item and 'iterating' through the statements until the required conditions are met.\\
A similar approach can be taken to find items with exactly one statement matching certain criteria, required for 	Multi-value. The idea is to ask the question if a second statement exists, then evaluating it as above. Both methods will be explained in section \ref{sec_statement_nonexistence}.

\section{Task}
Each property constraint will be modelled and evaluated as one set of rules per property per constraint, meaning each violating statement will be of a form similar to
\begin{equation}
\begin{split}
\text{violation}(X, Y, \text{propertyConstant}, Z) \leftarrow \text{atoms determining the violation}
\end{split}
\end{equation}
where propertyConstant denotes the constrained property. While it would be possible to load all data at once and restrict the property constant with a separate predicate akin to
\begin{equation}
\begin{split}
\text{violation}&(X, Y, \text{PROPERTY}, Z) \leftarrow \\
&\text{constrained}(\text{PROPERTY}, \text{constrainedConstant}) \wedge\\
&\text{rules determining the violation}
\end{split}
\end{equation}
this would increase the amount of facts loaded significantly while almost not reducing preprocessing.\\

The task for each constraint is thus: Given the constraint and a constrained property, potentially with qualifiers, which rule finds all violations of the rule in a given set of triples, qualifiers and references if applicable? The necessary preprocessing and filtering will be listed and the amount of rules necessary to model the constrained depending on the number of qualifiers given.

\subsection{General approach}
The goal outlined above is to identify violations of constrained properties, meaning a triple, qualifier, or reference with the constrained property will always be part of the rule body. With the exception of Property scope all constraints work on triples. The atom that will thus always be included is \(\text{tripleEDB}(X, Y, \text{propertyConstant}, Z)\).\\

Every constraint violation depends on some constant in relation to the constrained statement. These requirements have been roughly identified in the previous chapter and will now be specified as rules. This step can include expanding the pre-processing to load more data such as units for quantities.\\

The second step is the most complex: Depending on the constrained statement and the requirements, has a violation occurred? For the easiest category of constraints this step does not entail any additional work since the existence of the dependent structure is itself a violation. However, most constraints require at least evaluation of inequality between allowed values and existing values (\ref{sec_inequality}) or the non-existence of certain facts (\ref{sec_statement_nonexistence}). Both processes will be explained in their respective sections.

The final step of translation is not necessary to identify violations per se, but provides additional information as to where exactly a violation has occurred. \todo[inline]{lets see how much we can actually do here}

\section{No additional pre-processing}\label{sec_no_preprocessing}
Four constraints do not require any additional features and can be easily translated, since they are violated if specific statements exists. A violation of these statements is thus always a triple, qualifier, or reference and violations will be expressed as the result of a query atom
\[\text{violation\_triple}(S, I, P, V)\]
\[\text{violation\_qualifier}(S, P, V)\]
\[\text{violation\_reference}(S, P, V)\]
where \(S\) specifies the statement ID, \(I\) the item, \(P\) the property, and \(V\) the value. The term propertyConstant will be used for the constant of the constrained property.

\subsection{Property scope (Q53869507)}
The property scope constraint requires no context information to be violated; the triple, qualifier, or reference with the constrained property is enough.
A violation for a property scope constraint is
\[\text{violation\_triple}(S, I, \text{propertyConstant}, V) \leftarrow \text{tripleEDB}(S, I, \text{propertyConstant}, V)\]
\[\text{violation\_qualifier}(S, \text{propertyConstant}, V) \leftarrow \text{qualifierEDB}(S, \text{propertyConstant}, V)\]
\[\text{violation\_reference}(S, \text{propertyConstant}, V) \leftarrow \text{referenceEDB}(S, \text{propertyConstant}, V)\]
depending on if as main value, as qualifier, or as reference was not set in the qualifiers.\\

There is no further information that can be materialized regarding this violations.

\subsection{Conflicts-with (Q21502838)}
The conflicts-with constraint is violated if another statement on the same item either has a conflicting property or a conflicting property and a conflicting value depending on specified qualifiers. It depends on a conjunction (\(O\) denoting another statement ID, \(C\) another value) and a violation for a conflicts-with constraint is thus either
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow\\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge\\
&\text{tripleEDB}(O, I, \text{conflictingPropertyConstant}, C)
\end{split}
\end{equation*}
for constraints with no conflicting values specified or one
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow\\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge\\
&\text{tripleEDB}(O, I, \text{conflictingPropertyConstant}, \text{conflictingValueConstant})
\end{split}
\end{equation*}
for each conflicting value if specified.\\

\subsection{Allowed entity types (Q52004125)}
The allowed entity types constraint is violated by a statement with the wrong entity type. This means that during extraction additional data has to be readied. To encode this two new predicates are introduced, item\([1]\) and property\([1]\). All items and properties with a constrained statement will then be sorted into one of these two categories. Constraints regarding the lexeme entity type can be ignored since they are currently not deployed. The violations the depend on a simple conjunction and follow directly as
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \text{item}(I)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \text{property}(I)
\end{split}
\end{equation*}

\subsection{None of (Q52558054)}
The none of constraint simply forbids certain values for properties, thus effectively prohibiting certain triples, qualifiers and references. The violations, depending on nothing but specific database entries, are
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, \text{forbiddenValueConstant}) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, \text{forbiddenValueConstant})
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_qualifier}&(S, \text{propertyConstant}, \text{forbiddenValueConstant}) \leftarrow \\
&\text{qualifierEDB}(S, \text{propertyConstant}, \text{forbiddenValueConstant})
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_reference}&(S, \text{propertyConstant}, \text{forbiddenValueConstant}) \leftarrow \\
&\text{referenceEDB}(S, \text{propertyConstant}, \text{forbiddenValueConstant})
\end{split}
\end{equation*}

\section{Inequality}\label{sec_inequality}
All rules except the four covered in the previous section require inequality in some way or another. This means it is necessary to extract additional information during pre-processing, namely the constants for whom inequality needs to be stated. Each constraint will list the possible unequal entities in relation to the constrained statement. Multiple ways of implementing inequality while keeping the number of rules small will be discussed. Afterwards all constraints that can be translated using inequality will be explained.

\subsection{Approaches}
In every approach it will be necessary to load some basic inequalities into the database. To this end the predicate unequalEDB\([2]\) is introduced. Since the goal is to keep the number of applications of this predicate small, an IDB predicate unequal\([2]\) has to be introduced. This leads to the linear rule
\begin{equation*}
\text{unequal}(X, Y) \leftarrow \text{unequalEDB}(X, Y)
\end{equation*}

Given a set of entities \(E\), the task is to generate rules so that \(\forall x, y \in E, x \ne y: \text{unequal}(x, y)\). In doing so, dependent on the number of entities \(n = |E|\), the sum of the number of introduced EDB facts \(f(n)\) and the number of introduced rules \(r(n)\) should be kept as small as possible. Note that \(n > 1\) is presumed. The effects will be evaluated in section \ref{sec_inequality_evaluation}.

\todo[inline]{How are the three numbers weighted? Or do I determine that in evaluation?}
\todo[inline]{Is the number of materialised facts even relevant? Maybe look at rule applications.}
%, and the number of materialised facts \(m(n)\)
\subsubsection{Naive}\label{subsubsec_naive}
The naive approach would be to to simply add all possible combinations:
\begin{equation*}
\forall x, y \in E, x \ne y \text{ add } \text{unequalEDB}(x, y)
\end{equation*}.
This can be easily improved using the inverse and adding the following rule:
\begin{equation}\label{equ_inverse}
\text{unequal}(X, Y) \leftarrow \text{unequal}(Y, X)
\end{equation}
The it is sufficient to add each combinations once if disregarding their order:
\begin{equation*}
\forall x, y \in E, x < y \text{ add } \text{unequalEDB}(x, y)
\end{equation*}.

The naive approach with inverse would result in \(f(n) = \binom{n}{2}\) EDB facts and \(r(n) = 1\) additional rule.
%and \(m(n) = \binom{n}{2}\) materialized facts since equation \ref{equ_inverse} would be applied exactly once to every EDB fact.

\subsubsection{Encoding}
One option to determine inequality would be to utilise that all entities are strings of single characters. The idea is to determine the set of characters used in all entities \(C\), set them as unequal as outlined above in section \ref{subsubsec_naive} and associate each entity with their characters.\\

An entity \(e \in E\) is always a string and can be written as \(c_0 \ldots c_{l - 1}\) with \(l = len(e)\) being the length of the string. Denote the set \(C = \{c | \exists e \in E: c \in e\}\)\todo{\(c \in e\) does not seem correct} as the set of characters occurring in entities. Then \(l_{\max} = \max\limits_{\forall e \in E}(len(e))\) is the length of the longest entity string. Based on this a group of predicates letter\_iEDB[2] is introduced where \(i \in \{0 \ldots l_{\max}-1\}\) and letter\_iEBD denotes the ith letter of the entity string.\\

For each entity string \(e = c_0 \ldots c_{l - 1}\) each predicate letter\_iEDB is created as \(\text{letter\_iEDB}(e, f(e, i))\), where
\begin{equation*}
f(e, i) = 
\begin{cases}
      c_i & i < len(e) \\
      \text{NONE} & i \geq len(e)
\end{cases}
\end{equation*}

Now that inequality between all constitution characters and the link between entities and their characters are introduced, the inequality between two entities can be derived by creating the following rules for all predicates letter\_i:
\begin{equation*}
\text{unequal}(X, Y) \leftarrow \text{letter\_i}(X, A) \wedge \text{letter\_i}(Y, B) \wedge \text{unequal}(A, B)
\end{equation*}

With this approach the statistics depend on the number of distinct characters \(n_c = |C|\). The number of introduced EDB facts is \(f(n, n_c) = \binom{n_c}{2} + n*l_{\max}\) and the number of introduced rules \(r(n, n_c) = 1 + l_{\max}\). The effectiveness of this approach thus depends on the ratio between \(n\) and \(n_c\).

\subsubsection{Demand-driven materialization}

\section{Statement nonexistence}\label{sec_statement_nonexistence}

\chapter{Evaluation/Comparison}

\section{Inequality evaluation}\label{sec_inequality_evaluation}
\end{document}
