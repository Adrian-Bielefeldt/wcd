\documentclass[hyperref,bachelorofscience,fleqn]{cgvpub}
%weitere Optionen zum Ergänzen (in eckigen Klammern):
% 
% bibnum	numerische Literaturschlüssel
% final 	für Abgabe	
% lof			Abbildungsverzeichis
% lot			Tabellenverzeichnis
% noproblem	keine Aufgabenstellung
% notoc			kein Inhaltsverzeichnis
% twoside		zweiseitig
\author{Adrian Bielefeldt}
\title{Title}
\birthday{15. October 1994}
\placeofbirth{Dresden}
\matno{3694323}
\betreuer{Prof. Dr. Markus Krötzsch}
\bibfiles{literatur}
\problem{problem}
\copyrighterklaerung{copyright stuff}
\acknowledgments{Acknowledgements}
\abstracten{abstract text English}

\usepackage{rotating}
\usepackage{float}
\restylefloat{table}
\usepackage{makecell}
\renewcommand{\cellalign}{tl}
\usepackage{tabularx}
\usepackage{todonotes}
\usepackage{adjustbox}

\setcounter{tocdepth}{1}

\begin{document}
\chapter{Introduction/Preliminaries}
Motivation
\newpage
\section{Wikidata}
Wikidata is the knowledge base sister project of Wikipedia. It is a public, open database system that, at its core, stores statements about specific items. The basic unit of information is a triple subject-predicate-object stating an item (subject) has a property (predicate) which is either another item or a value of some kind (object). These store the relations of entities with each other or with specific data. An entity is either an item, which represents a topic, concept or real world entity, or a property, which denotes a relation an item has to another or with a value. They have numeric identifiers that are prefixed with Q and P respectively. A value is one of several data types noted in table \ref{tab_datatypes}, although it is also possible to use none or some as values for statements that have no value (akin to negation) or have a currently unknown value. Every property determines the data type it accepts as an object. \\

\begin{table}[H]
\caption{wikidata data types}\label{tab_datatypes}
\begin{tabularx}{\textwidth}{lllX}
Data type & Fields & Description \\
\hline
string & string (string) & simple string literal \\
globecoordinate & \makecell{latitude (float) \\ longitude (float) \\ precision (float) \\ globe(URI)} & \makecell{coordinates on a given celestial body \\ or geographic standard} \\
quantity & \makecell {amount (decimal) \\ upperBound (decimal) \\ lowerBound (decimal) \\ unit (URI or 1)} & \makecell{quantity of a specified unit (or none) \\ with uncertainty} \\
time & \makecell {time (string) \\ calendarmodel (URI) \\ precision (integer)} & \makecell {time as a string according to calendarmodel \\ (julian or gregorian),\\ with precision mapping to orders of magnitude \\ (e.g.. 10 years, months)} \\
\end{tabularx}
\end{table}

While this is similar to RDF and Wikidata has in fact been exported as RDF \cite{EGKMV2014}, the data structure is more complex than simple triples. It allows, to store additional information about statements. This is done via a statement ID, which is assigned to every triple storing information about an item. Every statement can be references by qualifiers and references which contain a predicate and an object, but have no item as subject but instead the statement ID. Qualifiers provide contextual information for statements. The most common context is the time frame in which the statement was accurate, e.g. stating the start and end times of a head of state, but other information is possible, e.g. determination method for measurements or the elevation above sea level for the highest point. References are information that supports the claim by citing the source and possibly additional information like when it was retrieved or when the source was published.

Other information regarding items like labels and descriptions in different languages as well as aliases and site links to other Wikimedia projects are also part of the data model but are not subject to constraints and are thus not explored further.
\section{Datalog}
Datalog is a logic programming language. It is fully declarative and uses existential rules to derive additional knowledge from given facts. The most basic unit of information in datalog is a \emph{constant}, which will be denoted as someConstant. In the context of Wikidata any item or property, e.g. Earth (Q2) or head of government (P6), could be represented as a constant. Relations in datalog are expressed as \emph{predicates} with a specified arity \(n\), written as predicate\([n]\). To stay close to Wikidata in our examples let us take the predicate statement\([3]\) as an example. This would be used to express the \emph{item}-\emph{property}-\emph{value} relation with each position representing one part of the triple.\\
Additionally, datalog also knows \emph{variables}, which will be capitalized like \(X\). Constants and variables are collectively known as \emph{terms} and are, together with predicates, used to form \emph{atoms}. An atom has the form predicate\((t_1, \ldots , t_n)\) with \(n\) as the arity of the predicate and \(t_1,\ldots,t_n\) terms.\\
Atoms are the building blocks of \emph{existential rules}, which are used to derive information in datalog. A rule is premise that implies a conclusion, and both are conjunctions of atoms. Denote \(P_n\) as the premise atoms, \(C_n\) as the conclusion atoms. The variables used are divided into three disjunct sets \(V_p\), \(V_c\), and \(V_r\) which are the variables occurring only in premise atoms, only in conclusion atoms, and occurring in both respectively. The general from of an existential rule is (with \(k \in \mathbb{N}^+\), \(l \in \mathbb{N}\))
\begin{equation*}
\forall p \in V_p, r \in V_r : \exists c \in V_c: C_1 \ldots C_k \leftarrow P_1 \ldots P_l
\end{equation*}

\(V_c\) are called existential variables. If \(V_c = \emptyset\) the rule is called a \emph{datalog rule} and if \(l = 0\) is called a \emph{fact}. Since \(\forall p \in V_p, r \in V_r\) can be taken as given for all rules, it will be omitted in this work.

Within the rule predicates we can differentiate between two different schemas: the \emph{extensional schema} and the \emph{intensional schema}, called EDB and IDB \todo{Shouldn't this be called \\EDP/IDP?} (extensional/intensional database predicate). An EDB may only occur in the premise of a rule, meaning it can never be derived. All others (predicates that appear in the conclusion at least once) are IDB.

For the following example taken from Wikidata descriptive names will be used instead of the IDs to increase readability. The individual entities and properties are introduced with their ID beforehand so the example can be retraced. The blue whales (Q42196) parent taxon (P171) is balaenoptera (Q133320), which in turn has the parent taxon rorqual (Q232829). The predicates used are tripleEDB\([3]\) as the input and isInTaxonIDB\([2]\), which will be derived. The basic facts are:\\
\[\text{tripleEDB}(\text{blue whale}, \text{parent taxon}, \text{balaenoptera})\]
\[\text{tripleEDB}(\text{balaenoptera}, \text{parent taxon}, \text{rorqual})\]
From this we can draw conclusions. The first step is to represent the already existing facts as IDB:
\[\text{isInTaxonIDB}(X, Y) \leftarrow \text{tripleEDB}(X, \text{parent taxon}, Y)\]
Finally the transitive closure of this relation can be derived with
\[\text{isInTaxonIDB}(X, Y) \leftarrow \text{isInTaxonIDB}(X, Z) \wedge \text{isInTaxonIDB}(Z, Y)\]

\todo[inline]{Should I explain the chase? And in what detail...}
\section{Representation}
To model the basic representation of triples, qualifiers and references three predicates are introduced.\\
tripleEDB\([4]\) represents a single statement consisting of the statement ID, the item ID, the property ID and the value as either and item ID or a string-representation of the data value.\\
qualifierEDB\([3]\) and referenceEDB\([3]\) represent the qualifiers and references on a given statement ID with their respective property id and the value as usual.\\

Additional predicates modelling different pre-processing steps are explained in chapter \ref{cha_rules}.
\section{Terminology}
\begin{table}[H]
\caption{abbreviations}
\begin{tabular}{ll}
Shorthand & Description \\
\hline
constrained statement & statement with the constrained property as predicate \\
constrained qualifier & qualifier with the constrained property as predicate \\
constrained reference & reference with the constrained property as predicate \\
constrained item & item with a constrained statement \\
item statement & statement on the same item of a constrained statement \\
value statement & statement on the value of a constrained statement
\end{tabular}
\end{table}
\chapter{Property Constraints}

To improve the data quality, help editors avoid common mistakes and clarify the usage of properties, Wikidata allows constraints to be defined on properties. They are however not firm rules and exceptions can and should be made if necessary. A property constraint says something about the way a property may or may not be used. This can mean simple restrictions on the statement a property is part of, e.g. only certain values are allowed or more complex requirements on connected parts of the data graph, e.g. the value of a statement with this property should have certain statements. Further down you can find table \ref{tab_property_constraints}, which list the existing property constraints. Afterwards the constraints will be explained in detail and either a basic approach for their modelling or reasoning why it is not possible or sensible to model it given.\\

To apply a constraint to a property a statement <property> <P2302> <constraint> is added to the properties item page, where <property> is the property that should be constrained, <P2302> (property constraint) denotes that the property has a constraint and <constraint> is the specific constraint. Note that a constrained statement means a statement whose predicate is a property that has a specific constraint. A simple example for this would be distinct values (Q21502410) stating that values of the property must be unique across all constrained statements. For this case no additional information regarding the constraint is necessary and violation could be found by surveying all constrained statements and comparing their values.\\
Constraints can be further specified by using qualifiers on the constraint statement. These qualifiers are either optional or mandatory and may be applied once or multiple times. For example, the none of constraint (Q52558054) states that values for a specific property may not be in a set of disallowed values. These are specified as qualifiers using item of property constraint (P2305) on the constraint statement and require at least one such statement.\\
More complex dependencies are also possible. A constraint can depend on all constrained statements of a specific item (single value constraint [Q19474404]), on all statements of the value of a constrained statement (value requires statement constraint [Q21510864]) or in the most complex case on all statements using the subclassOf-predicate (type constraint [Q21503250]).

Table \ref{tab_property_constraints} shows all currently used property constrains in Wikidata. It is sorted by difficulty, which is an estimate of the necessary pre-processing and rule complexity based on required features. These required features are conditions that cannot natively be expressed in datalog and would require some kind of pre-processing to be made available. Difficulty 0 does not need any pre-processing except for loading the data into datalog as ground rules. 1 requires inequality, which can be easily solved with brute force but will be improved in chapter \ref{cha_rules}. 2 needs negation in a form that can be solved without pre-processing everything and 3 in a form that would require all logic as part of pre-processing. Other features needed for category three are regular expressions, which could theoretically be translated but would require large amounts of pre-processing, value comparison, general negation and finally web requests to test if a link is valid.

\begin{table}[H]
\caption{property constraints}\label{tab_property_constraints}
\begin{tabularx}{\textheight}{rrllllX}
Difficulty & \makecell{\# constrained\\ properties} & Identifier & Name & Required Features \\
\hline
0 & 1410 & Q53869507 & Scope &  \\
0 & 781 & Q21502838 & Conflicts with &  \\
0 & 27 & Q52004125 & Allowed entity types &  \\
0 & 17 & Q52558054 & None of &  \\
1 & 2843 & Q21502410 & Distinct value & Inequality \\
1 & 343 & Q21514353 & Allowed units & Inequality \\
1 & 303 & Q21510851 & Allowed qualifiers & Inequality \\
1 & 116 & Q21510859 & One of & Inequality \\
1 & 3 & Q52060874 & Single best value & Inequality \\
1 & 1 & Q52712340 & One-of qualifier value & Inequality \\
2 & 4265 & Q21503247 & Item requires statement & Negation (statement non-existence) \\
2 & 244 & Q21510864 & Value requires statement & Negation (statement non-existence) \\
2 & 119 & Q21510855 & Inverse & Negation (statement non-existence) \\
2 & 33 & Q21510862 & Symmetric & Negation (statement non-existence) \\
2 & 13 & Q21510857 & Multi-value & Negation, Count (up to two) \\
2 & 2909 & Q19474404 & Single value & Inequality, partially negation (qualifier non-existence) \\
2 & 203 & Q21510856 & Mandatory qualifier & Negation (qualifier non-existence) \\
3 & 2613 & Q21503250 & Type & Negation (derived fact negation) \\
3 & 707 & Q21510865 & Value type & Negation (derived fact negation) \\
3 & 3021 & Q21502404 & Format & Regular expressions \\
3 & 188 & Q21510860 & Range & Value comparison \\
3 & 106 & Q52848401 & Integer & Regular expressions \\
3 & 65 & Q51723761 & No bounds & Negation \\
3 & 53 & Q21510852 & Commons link & Web request \\
3 & 10 & Q54554025 & Link & Negation \\
3 & 6 & Q21510854 & Difference within range & Value comparison \\
3 & 1 & Q25796498 & Contemporary constraint & Negation \\
\end{tabularx}
\end{table}


\section{Wikidata constraints explained}
This section will explain all interesting, meaning translatable or partially translatable, currently used property constraints on Wikidata. They will be presented roughly in descending order of the number of properties with this constraint, although constraints with similar function will be explained directly after one another. Also, all constraints that were considered untranslatable are listed at the and, each with a short explanation as to why they were placed in that group.\\

Every constraint will start with a table showing basic properties of the constraint. This includes the requirement, relevant qualifiers, possible violations of the constraint and the data the constraint depends on. The requirement states which part of the data graph in relation to the constrained statement are restricted or need to exist. The qualifiers list their cardinality, meaning if they are required and if they may be used multiple times, and a short description. The violations list the conflicting (part of a) statement in relation to the constrained statement. The dependencies list their relation to the constrained statement. Table \ref{tab_example_constraint} shows the formatting as an example.

\begin{table}[H]
\caption{example constraint (Q31415926)}\label{tab_example_constraint}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & requirement \\
\hline
Qualifiers & \makecell{example qualifier (P1234) -- 1..* \\ description \\ another qualifier (P4321) -- 0..1 \\ different description} \\
\hline
Violation & \makecell{one way to violate the constraint \\ another violation possibility} \\
\hline
Dependency & statements, qualifiers or references in relation to the constrained statement\\
\hline
Rule features & features needed (missing if no features needed) \\
\hline
\end{tabularx}
\end{table}

\subsection{Property scope (Q53869507)}
The property scope constraint specifies if a property may be used in a statement, qualifier or reference as predicate.
\begin{table}[H]
\caption{property scope constraint (Q53869507)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement \\
\hline
Qualifiers & \makecell{property scope (P5314) -- 1..3 \\ must be as main value (Q54828448), as qualifier (Q54828449) or as reference (Q54828450) \\ specifies allowed use in statements, qualifiers or references} \\
\hline
Violation & constrained statement in a position that is not allowed \\
\hline
Dependency & constrained statement, qualifier or reference \\
\hline
\end{tabularx}
\end{table}

Since only three possibilities exist, this is equivalent to forbidding all other possibilities and the rules are simple mapping all of tripleEDB, qualifierEDB and referenceEDB with the constrained property that are not allowed.

\subsection{Conflicts-with (Q21502838)}
The conflicts with constraint forbids either certain statements or statements with a specific property on constrained items.
\begin{table}[H]
\caption{Conflicts-with constraint (Q21502838)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & item statement \\
\hline
Qualifiers & \makecell{conflicting property (P2306) -- 1 \\ property no item statement may have (with conflicting values if specified) \\
conflicting values (P2305) -- 0..* \\ values that may not appear in item statements with the conflicting property} \\
\hline
Violation & \makecell{item statement with the conflicting property \\ item statement with the conflicting property and one of the conflicting values} \\
\hline
Dependency & all item statements \\
\hline
\end{tabularx}
\end{table}
The rule modelling can simply be done by choosing all tripleEDB with the constrained property and then all tripleEDB on the same item with the conflicting property, specifying the values as well if necessary.

\subsection{Allowed entity types (Q52004125)}
The allowed entity types constraint limits if a property may be used on an item, a property or a lexeme, although lexemes are not yet deployed.

\begin{table}[H]
\caption{Allowed entity types constraint (Q52004125)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement \\
\hline
Qualifiers & \makecell{allowed entity type (P2305) -- 1..3 \\ must be wikibase item (Q29934200), wikibase property (Q29934218) \\ or lexeme (Q51885771); \\ specifies the type the property may be used on} \\
\hline
Violation & \makecell{constrained statement on an entity of a type unequal to all allowed types} \\
\hline
Dependency & constrained statement and entity type of the subject \\
\hline
\end{tabularx}
\end{table}

Since there are only three options (and only two in use), violations can be found without inequality by finding the tripleEDB with the constrained property whose subject is of the type that is not allowed, meaning either wikibase item or wikibase property.

\subsection{None of (Q52558054)}
The none of constraint restricts the values that the property may refer to by listing a set of values as forbidden.

\begin{table}[H]
\caption{None of constraint (Q52558054)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement \\
\hline
Qualifiers & \makecell{forbidden value (P2305) -- 1..* \\ values that may not appear in a constrained property} \\
\hline
Violation & \makecell{constrained statement with a forbidden value} \\
\hline
Dependency & constrained statement \\
\hline
\end{tabularx}
\end{table}

Modelling this constraint is very straightforward, since each forbidden value forms a property-value pair with the constrained statement that may not exists. Thus a violations is a tripleEDB with the constrained statement and a forbidden value.

\subsection{Distinct values (Q21502410)}
The distinct values constraint forbids the existence of two constrained statements with the same value.
\begin{table}[H]
\caption{distinct values constraint (Q21502410)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement value \\
\hline
Violations & two constrained statements with same value \\
\hline
Dependency & all constrained statements\\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}
To model the distinct values constraint it is necessary to find triples tripleEDB with the constrained property and the same value whose statement id is unequal. In theory the constraint can also be applied to qualifiers and references by setting the respective value on a constraint scope (P4680) qualifier. However, there is currently no such case and will therefore not be regarded.

\subsection{Allowed units (Q21514353)}
The allowed units constraint specifies that a constrained statement may only have a unit that is in a set of specific units.

\begin{table}[H]
\caption{Allowed units constraint (Q21514353)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement unit \\
\hline
Qualifiers & \makecell{allowed unit (P2305) -- 1..* \\ units that the statement may have (or none for dimensionless units)} \\
\hline
Violation & \makecell{constrained statement with a unit unequal to all allowed units} \\
\hline
Dependency & constrained statement and its unit \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

Modelling the constraint requires a predicate associating the value or the statement with its unit and inequality between every unit and all allowed units. Then a violation can be found by finding all tripleEDB, qualifierEDB and referenceEDB with the constrained property and a unit unequal to all allowed units. Theoretically some of these can be excluded by using the constraint scope (P4680) qualifier on the constraint but there is no current case where this is done.

\subsection{Allowed qualifiers (Q21510851)}
The allowed qualifiers constraint specifies that only a limited set of properties may be used as qualifiers on a constrained statement.

\begin{table}[H]
\caption{Allowed qualifiers constraint (Q21510851)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & qualifier on constrained statement \\
\hline
Qualifiers & \makecell{	allowed qualifier (P2306) -- 1..* \\ qualifiers that the statement may have} \\
\hline
Violation & \makecell{constrained statement with a qualifier unequal to all allowed qualifiers} \\
\hline
Dependency & constrained statement and its qualifiers \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

To represent a violation of this constraint in datalog inequality between all specified allowed qualifiers and the properties of the qualifiers on constrained statements is required. A tripleEDB with the constrained property and a qualifierEDB on that statement with a property different from all allowed qualifiers would violate the constraint.

\subsection{One-of (Q21510859)}
The one-of constraint limits the values a property may use to a set of given values.

\begin{table}[H]
\caption{One-of constraint (Q21510859)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement \\
\hline
Qualifiers & \makecell{allowed values (P2305) -- 1..* \\ values that may be used in the constrained statement} \\
\hline
Violation & \makecell{constrained statement with a value unequal to all allowed values} \\
\hline
Dependency & constrained statement \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

Modelling the one-of constraint requires a rule finding a tripleEDB with the constrained property whose value is unequal to all allowed values, meaning the inequality between each value of constrained statements and all allowed values must be given.

\subsection{One-of qualifier value (Q52712340)}
The one-of qualifier value constraint restricts which values may be used on a qualifier with a given property on a constrained statement.

\begin{table}[H]
\caption{One-of qualifier value constraint (Q52712340)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement qualifier value \\
\hline
Qualifiers: & \makecell{qualifier property (P2306) -- 1 \\ property of the restricted qualifier\\
qualifier values (P2305) -- 1..* \\ values the qualifiers may take}\\
\hline
Violation & \makecell{constrained statement with a qualifier with the qualifier property and a value unequal to all qualifier values} \\
\hline
Dependency & constrained item and qualifiers with the qualifier property \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

The constraint can be modelled if the inequality between a value of a qualifier property with all qualifier values is given. The violations could then be found by taking a tripleEDB with the constrained property and a qualifier with the qualifier property on the former statement whose value is unequal to all qualifier values.

\subsection{Item requires statement (Q21503247)}\label{subsec_2_item_requires_statement}
The item requires statement constraint requires an additional statement on an item with a statement using the constrained property, possibly also using a specific value from the list of allowed values.
\begin{table}[H]
\caption{item requires statement constraint (Q21503247)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & item statement \\
\hline
Qualifiers & \makecell{required property (P2306) -- 1 \\ property the item statement must have \\ allowed value (P2305) -- 0..* \\ values the item statement may have} \\
\hline
Violation & \makecell{no item statement with required property \\ all item statements with required property have no allowed value} \\
\hline
Dependency &  all item statements\\
\hline
Rule features & negation \\
\hline
\end{tabularx}
\end{table}

An item violates the constraint if it a) has a statement using constrained property as predicate, b1) has no statement using the required property as predicate, or (if allowed values are specified) b2) has only statement using required property as predicate that do not use one of the allowed values as value.\\
While condition a) can easily be tested by a tripleEDB-atom with the constrained property, condition b1) and b2) pose the question if an item does not have a statement. This is addressed in section [?].

\subsection{Value requires statement (Q21510864)}\label{subsec_2_value_requires_statement}
The value requires statement constraint requires an additional statement on the value of constrained statement, possibly also using a specific value from the list of allowed values. Since the constraint works very similar to item requires statement (see \ref{subsec_2_item_requires_statement}) --- requiring a statement on the value of the constrained statement instead of on the item --- it is not elaborated on.

\subsection{Inverse (Q21510855)}\label{subsec_2_inverse}
The inverse constraint requires an additional statement on the value of a constrained statement with a specific property and the constrained item as value. It is very similar to value requires statement (see \ref{subsec_2_value_requires_statement}), although it does not specify allowed values, since the required statement has one specific value: the constrained item. While this means it could not be modelled exactly as a value requires statement constraint, it would only require very small rule changes and will thus not be elaborated on.

\subsection{Symmetric (Q21510862)}
The symmetric constraint requires an additional statement on the value of a constrained statement with the constrained property and the constrained item as value. It is thus equal to an inverse constraint (see \ref{subsec_2_inverse}) with the same property as constrained property and required property and will not be elaborated on.

\subsection{Multi-value (Q21510857)}
The multi-value constraint specifies that the constrained property should appear in multiple statements of an item or none.

\begin{table}[H]
\caption{Multi-value constraint (Q21510857)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & item statement \\
\hline
Violation & \makecell{constrained item with exactly one constrained statement} \\
\hline
Dependency & all item statements \\
\hline
Rule features & count \\
\hline
\end{tabularx}
\end{table}

To model this constraint a count of statements using the constrained property per item would be needed. Then a violation would be any constrained item with a count of one for the constrained property. Since there is no need for arbitrarily large counts, but only for the difference between one and two, this could be solved explicitly.

\subsection{Single value (Q19474404)}
The single value constraint constrains the values a property may take on a single item. A property marked with the single value constraint can have properties marked as separators, which define exceptions under specific circumstances.
\begin{table}[H]
\caption{single value constraint (Q19474404)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & constrained statement value \\
\hline
Qualifiers & \makecell{separator (P4155) -- 0..* \\ qualifiers that must be different for exception} \\
\hline
Violation & \makecell{two constrained statements with same item and value \\ (exception: statements with separators as qualifiers with different values)} \\
\hline
Dependency & \makecell{without separators: all constrained statements on one item \\ with separators: additionally all qualifiers with separators on those statements }\\
\hline
Rule features & inequality, partially negation \\
\hline
\end{tabularx}
\end{table}

If no separators are specified, two triple form a violation of this constraint if they a) belong to the same item, b) have the same constrained property, and c) have the same value.
If separators are specified, a violation as above can be ignored if the statements each have at least one qualifier with the same separator as predicate and different values or an unequal number of separator qualifiers.\\
In the case without separators the modelling idea would be to find two triples tripleEDB with the same item and constrained property and test if their id is unequal. If separators were specified a violation would be the two triples and all their separator qualifiers equal or non-existent.
\todo{Since I found the details via looking at the source code, should/can I cite that?}

\subsection{Mandatory qualifier (Q21510856)}
The mandatory qualifier constraint requires that a constrained statement has a qualifier with a specific property.

\begin{table}[H]
\caption{Mandatory qualifier constraint (Q21510856)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & qualifier on constrained statement \\
\hline
Qualifiers & \makecell{required property (P2306) -- 1 \\ qualifier that the statement must have} \\
\hline
Violation & \makecell{constrained statement without a qualifier with the required property} \\
\hline
Dependency & constrained statement and its qualifiers \\
\hline
Rule features & negation \\
\hline
\end{tabularx}
\end{table}

To find violations of this constraint one would find a tripleEDB with the constrained property, but where no qualifierEDB for the statement and with the required property exists.

\subsection{Single best value (Q52060874)}
The single best value constraint requires that only one constrained statement per item has the rank preferred.

\begin{table}[H]
\caption{Single best value constraint (Q52060874)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & item statement rank \\
\hline
Violation & \makecell{items with two constrained statements with rank preferred} \\
\hline
Dependency & all item statements and their rank \\
\hline
Rule features & inequality \\
\hline
\end{tabularx}
\end{table}

Modelling the constraint means a count of all constrained statements with rank preferred is necessary, with a violation constituted if an item has a count of two or higher. Since it is only needed to differentiate between one and many, the rules could be written explicitly.

\subsection{Type (Q21503250)}\label{subsec_2_type}
The type constraint requires the existence of either one of a specific statement (instanceOf <class>) or a chain of statements using subclassOf to connect directly (subclassOf* <class>)
or via instanceOf (instanceOf/subclassOf* <class>) for all classes on the constrained item.
\begin{table}[H]
\caption{type constraint (Q21503250)}
\begin{tabularx}{\textwidth}{ ll X}
\hline
Requirement & chain of statements \\
\hline
Qualifiers & \makecell{relation (P2309) -- 1 \\ must be instance of (Q21503252), subclass of (Q21514624), \\ or instance or subclass of (Q30208840); \\ specifies the relation the constrained item must have to the classes\\
class (P2308) -- 1..* \\ entities that must be reached using the relation} \\
\hline
Violation & constrained item without relation to a class \\
\hline
Dependency & \makecell{statements of constrained items using instanceOf (P31) or subclassOf(P279) \\ all statements using subclassOf (P279) }\\
\hline
Rule features & inequality, negation \\
\hline
\end{tabularx}
\end{table}

If the relation is instanceOf, the constraint can be evaluated like multiple item requires statement constraints (see \ref{subsec_2_item_requires_statement}) by setting the required property to instanceOf (P31) and, for each created item requires statement constraint, the allowed value to one of the classes. \\
For the relations involving subclasses all transitive subclass relationships would be concluded by setting a subclass relationship if a third item can be found that is subclass of one and subclassed by the other item. This would be extended with one step of instanceOf. A violation would then be any constrained item that is not subclass of any of the classes.

\subsection{Value type (Q21510865)}
The value type constraint works like the type constraint (see \ref{subsec_2_type}) except the statement chains are required on the value of the constrained statement instead of the constrained item. It will thus not be expanded upon.

\section{Reasoning for unconsidered constraints}
Multiple constraints have not been described above for different reasons. The most prominent of these is the format constraint (Q21502404) which specifies a regular expressions the values of the constrained property must adhere to. Evaluating these expressions would be theoretically possible but \\
a) primarily results in a large amount of preprocessing and\\
b) does not solve the question of negation, since violations would be values that do not conform to their required regular expression. \\

The integer constraint (Q52848401), which requires values of a constrained property be integers (notably a quantity without decimal places), could easily be seen as a specific format constraint. While precomputing if a value is an integer or not could be done, it would mean that no actually relevant rules would be needed for the evaluation in datalog. \\

Another problem that could not be sensibly solved is the comparison of values, needed for range (Q21510860), difference within range (Q21510854) and contemporary constraint (Q25796498). Range restricts the values of a constrained property within a certain range, difference within range specifies that two item statements should have values within a certain range and contemporary constraint specifies that subject and object of a constrained statement have to have coexisted at some point in time. While it would be possible to extract all values that might need to be compared and precompute the comparison, it would make most of the work precomputing and leave little to be done in datalog.\\

Link constraint (Q54554025), requiring that constraint statements must have one or more references, requires a negation that cannot be concluded except by explicitly precomputing it, which makes the evaluation unnecessary. \\
A similar situation is the no bounds constraint (Q51723761), which requires that quantity values have neither upper nor lower bound. While it would be possible to precompute if a statement has no upper or lower bound, this would shift basically all evaluation logic into precomputing.

And finally commons link constraint (Q21510852) requires that values for a property should be valid links to to Wikimedia Commons. This validity cannot be testes from within datalog since there is no way to query the web for information.


\chapter{Rules}\label{cha_rules}
The previous chapter has show that most constraints cannot be modelled without at least some amount of preprocessing. Only Scope, Conflicts with, Allowed entity types and None of can be modelled directly. This is due to the fact that Conflicts with and None of exclude a limited and specified set of statements from validity and these cases can thus be directly takes as violations. Scope and Allowed entity types work very similar, since there are only three respectively two possible values and violations are simply the options that have not been allowed.  The rules for these constraints are described in section \ref{sec_no_preprocessing}.\\

A problem that occurs multiple times is the need to determine inequality between constants. Distinct value, Allowed units, Allowed qualifiers, One of, Single best value and One-of qualifier value each require a rule to determine if a value, unit or property is not equal to another. To this end a certain amount of preprocessing is necessary, most notably the extraction of all constant pairs whose inequality has to be determined for finding the violations. To avoid putting and undue amount of processing outside of datalog this extraction will not check more than that the constant is in the right position relative to the constrained statement, e.g. all values on statements constrained by Distinct value or all qualifiers on statements constrained by Allowed qualifiers. From this set inequality will be generated, different versions of which will be introduced in section \ref{sec_inequality} and evaluated with regards to their performance in section \ref{sec_inequality_evaluation}.\\

Negation as a general problem cannot be solved in datalog. One could pre-process every necessary fact to be negated and add this to the ground facts, but this is not the purpose of this work. However, not all constraints require a general negation. Item requires statement, Value requires statement, Inverse and Symmetric are all violated if a statement does not exist on a specific item. This problem can be solved with limited amounts of preprocessing by leveraging a preprocessed statement order per item and 'iterating' through the statements until the required conditions are met.\\
A similar approach can be taken to find items with exactly one statement matching certain criteria, required for 	Multi-value. The idea is to ask the question if a second statement exists, then evaluating it as above. Both methods will be explained in section \ref{sec_statement_non-existence}.

\section{Task}
Each property constraint will be modelled and evaluated as one set of rules per property per constraint, meaning each violating statement will be of a form similar to
\begin{equation}
\begin{split}
\text{violation}(X, Y, \text{propertyConstant}, Z) \leftarrow \text{atoms determining the violation}
\end{split}
\end{equation}
where propertyConstant denotes the constrained property. While it would be possible to load all data at once and restrict the property constant with a separate predicate akin to
\begin{equation}
\begin{split}
\text{violation}&(X, Y, \text{PROPERTY}, Z) \leftarrow \\
&\text{constrained}(\text{PROPERTY}, \text{constrainedConstant}) \wedge\\
&\text{rules determining the violation}
\end{split}
\end{equation}
this would increase the amount of facts loaded significantly while almost not reducing preprocessing.\\

The task for each constraint is thus: Given the constraint and a constrained property, potentially with qualifiers, which rule finds all violations of the rule in a given set of triples, qualifiers and references if applicable? The necessary preprocessing and filtering will be listed and the amount of rules necessary to model the constrained depending on the number of qualifiers given.

\subsection{General approach}
The goal outlined above is to identify violations of constrained properties, meaning a triple, qualifier, or reference with the constrained property will always be part of the rule body. With the exception of Property scope all constraints work on triples. The atom that will thus always be included is \(\text{tripleEDB}(X, Y, \text{propertyConstant}, Z)\).\\

Every constraint violation depends on some constant in relation to the constrained statement. These requirements have been roughly identified in the previous chapter and will now be specified as rules. This step can include expanding the pre-processing to load more data such as units for quantities.\\

The second step is the most complex: Depending on the constrained statement and the requirements, has a violation occurred? For the easiest category of constraints this step does not entail any additional work since the existence of the dependent structure is itself a violation. However, most constraints require at least evaluation of inequality between allowed values and existing values (\ref{sec_inequality}) or the non-existence of certain facts (\ref{sec_statement_non-existence}). Both processes will be explained in their respective sections.

The final step of translation is not necessary to identify violations per se, but provides additional information as to where exactly a violation has occurred. \todo[inline]{lets see how much we can actually do here}

\section{No additional pre-processing}\label{sec_no_preprocessing}
Four constraints do not require any additional features and can be easily translated, since they are violated if specific statements exists. A violation of these statements is thus always a triple, qualifier, or reference and violations will be expressed as the result of a query atom
\[\text{violation\_triple}(S, I, P, V)\]
\[\text{violation\_qualifier}(S, P, V)\]
\[\text{violation\_reference}(S, P, V)\]
where \(S\) specifies the statement ID, \(I\) the item, \(P\) the property, and \(V\) the value. The term propertyConstant will be used for the constant of the constrained property.

\subsection{Property scope (Q53869507)}
The property scope constraint requires no context information to be violated; the triple, qualifier, or reference with the constrained property is enough.
A violation for a property scope constraint is
\[\text{violation\_triple}(S, I, \text{propertyConstant}, V) \leftarrow \text{tripleEDB}(S, I, \text{propertyConstant}, V)\]
\[\text{violation\_qualifier}(S, \text{propertyConstant}, V) \leftarrow \text{qualifierEDB}(S, \text{propertyConstant}, V)\]
\[\text{violation\_reference}(S, \text{propertyConstant}, V) \leftarrow \text{referenceEDB}(S, \text{propertyConstant}, V)\]
depending on if as main value, as qualifier, or as reference was not set in the qualifiers.\\

There is no further information that can be materialized regarding this violations.

\subsection{Conflicts-with (Q21502838)}
The conflicts-with constraint is violated if another statement on the same item either has a conflicting property or a conflicting property and a conflicting value depending on specified qualifiers. It depends on a conjunction (\(O\) denoting another statement ID, \(C\) another value) and a violation for a conflicts-with constraint is thus either
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow\\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge\\
&\text{tripleEDB}(O, I, \text{conflictingPropertyConstant}, C)
\end{split}
\end{equation*}
for constraints with no conflicting values specified or one
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow\\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge\\
&\text{tripleEDB}(O, I, \text{conflictingPropertyConstant}, \text{conflictingValueConstant})
\end{split}
\end{equation*}
for each conflicting value if specified.\\

\subsection{Allowed entity types (Q52004125)}
The allowed entity types constraint is violated by a statement with the wrong entity type. This means that during extraction additional data has to be readied. To encode this two new predicates are introduced, item\([1]\) and property\([1]\). All items and properties with a constrained statement will then be sorted into one of these two categories. Constraints regarding the lexeme entity type can be ignored since they are currently not deployed. The violations the depend on a simple conjunction and follow directly as
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \text{item}(I)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \text{property}(I)
\end{split}
\end{equation*}

\subsection{None of (Q52558054)}
The none of constraint simply forbids certain values for properties, thus effectively prohibiting certain triples, qualifiers and references. The violations, depending on nothing but specific database entries, are
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, \text{forbiddenValueConstant}) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, \text{forbiddenValueConstant})
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_qualifier}&(S, \text{propertyConstant}, \text{forbiddenValueConstant}) \leftarrow \\
&\text{qualifierEDB}(S, \text{propertyConstant}, \text{forbiddenValueConstant})
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_reference}&(S, \text{propertyConstant}, \text{forbiddenValueConstant}) \leftarrow \\
&\text{referenceEDB}(S, \text{propertyConstant}, \text{forbiddenValueConstant})
\end{split}
\end{equation*}

\section{Inequality}\label{sec_inequality}
All rules except the four covered in the previous section require inequality in some way or another. This means it is necessary to extract additional information during pre-processing, namely the constants for whom inequality needs to be stated. Each constraint will list the possible unequal entities in relation to the constrained statement. Multiple ways of implementing inequality while keeping the number of rules small will be discussed. Afterwards all constraints that can be translated using inequality will be explained.

\subsection{Approaches}
In every approach it will be necessary to load some basic inequalities into the database. To this end the predicate unequalEDB\([2]\) is introduced. Since the goal is to keep the number of applications of this predicate small, an IDB predicate unequal\([2]\) has to be introduced. This leads to the linear rule
\begin{equation*}
\text{unequal}(X, Y) \leftarrow \text{unequalEDB}(X, Y)
\end{equation*}

Given a set of entities \(E\), the task is to generate rules so that \(\forall x, y \in E, x \ne y: \text{unequal}(x, y)\). In doing so, dependent on the number of entities \(n = |E|\), the sum of the number of introduced EDB facts \(f(n)\) and the number of introduced rules \(r(n)\) should be kept as small as possible. Note that \(n > 1\) is presumed. The effects will be evaluated in section \ref{sec_inequality_evaluation}.

\todo[inline]{How are the three numbers weighted? Or do I determine that in evaluation?}
\todo[inline]{Is the number of materialised facts even relevant? Maybe look at rule applications.}
%, and the number of materialised facts \(m(n)\)
\subsubsection{Naive}\label{subsubsec_naive}
The naive approach would be to to simply add all possible combinations:
\begin{equation*}
\forall x, y \in E, x \ne y \text{ add } \text{unequalEDB}(x, y)
\end{equation*}.
This can be easily improved using the inverse and adding the following rule:
\begin{equation}\label{equ_inverse}
\text{unequal}(X, Y) \leftarrow \text{unequal}(Y, X)
\end{equation}
The it is sufficient to add each combinations once if disregarding their order:
\begin{equation*}
\forall x, y \in E, x < y \text{ add } \text{unequalEDB}(x, y)
\end{equation*}.

The naive approach with inverse would result in \(f(n) = \binom{n}{2}\) EDB facts and \(r(n) = 1\) additional rule.
%and \(m(n) = \binom{n}{2}\) materialized facts since equation \ref{equ_inverse} would be applied exactly once to every EDB fact.

\subsubsection{Encoding}\label{subsubsec_encoding}
One option to determine inequality would be to utilise that all entities are strings of single characters. The idea is to determine the set of characters used in all entities \(C\), set them as unequal as outlined above in section \ref{subsubsec_naive} and associate each entity with their characters.\\

An entity \(e \in E\) is always a string and can be written as \(c_0 \ldots c_{l - 1}\) with \(l = len(e)\) being the length of the string. Denote the set \(C = \{c | \exists e \in E: c \in e\}\)\todo{\(c \in e\) does not seem correct} as the set of characters occurring in entities. Then \(l_{\max} = \max\limits_{\forall e \in E}(len(e))\) is the length of the longest entity string. Based on this a group of predicates letter\_iEDB[2] is introduced where \(i \in \{0 \ldots l_{\max}-1\}\) and letter\_iEBD denotes the ith letter of the entity string.\\

For each entity string \(e = c_0 \ldots c_{l - 1}\) each predicate letter\_iEDB is created as \(\text{letter\_iEDB}(e, f(e, i))\), where
\begin{equation*}
f(e, i) = 
\begin{cases}
      c_i & i < len(e) \\
      \text{NONE} & i \geq len(e)
\end{cases}
\end{equation*}

Now that inequality between all constitution characters and the link between entities and their characters are introduced, the inequality between two entities can be derived by creating the following rules for all predicates letter\_i:
\begin{equation*}
\text{unequal}(X, Y) \leftarrow \text{letter\_i}(X, A) \wedge \text{letter\_i}(Y, B) \wedge \text{unequal}(A, B)
\end{equation*}

With this approach the statistics depend on the number of distinct characters \(n_c = |C|\). The number of introduced EDB facts is \(f(n, n_c) = \binom{n_c}{2} + n*l_{\max}\) and the number of introduced rules \(r(n, n_c) = 1 + l_{\max}\). The effectiveness of this approach thus depends on the ratio between \(n\) and \(n_c\).

\subsubsection{Demand-driven materialisation}
The approaches outlined above will always result in all inequalities between the members of \(E\) being materialised. However, the purpose of determining inequality is to assist in finding violations of specific constraints. This means that only some inequalities -- the ones that actually appear in the dataset -- have to be evaluated. The rules can then be limited by introducing a new predicate req\_inequality\([2]\) which will only be derived if a condition occurs in which the inequality must be evaluated.\\

To save space and avoid redundancy the following rules will not explicitly state the inequality requirement predicate. Instead, assume that for every premise with the form \(B_1 \wedge \ldots\wedge B_m \wedge I\) where \(B_1 .. B_m\) are arbitrary atoms, \(I\) is an atom of the form \(\text{unequal}(t_1, t_2)\) with \(t_1,t_2\) terms and all of \(t_1,t_2\) that are variables appear in at least one of \(B_1 \ldots B_m\), the rule 
\begin{equation*}
\text{req\_inequality}(t_1, t_2)
 \leftarrow B_1 \wedge \ldots \wedge B_m
\end{equation*} is introduced.\\

The rules outlined in section \ref{subsubsec_encoding} are changed to utilise this new requirement.
\begin{equation*}
\text{unequal}(X, Y) \leftarrow \text{req\_inequality}(X, Y) \wedge \text{letter\_i}(X, A) \wedge \text{letter\_i}(Y, B) \wedge \text{unequal}(A, B)
\end{equation*}

\todo{could use this to restrict the character inequality too but do we gain much?}

\subsection{Distinct values (Q21502410)}
The distinct values constraints requires two distinct constrained statements with the same value. 
While finding constrained statements with the same value is straightforward, violations only occur if the statements are actually different, i.e. have an unequal statement id.
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \\
&\text{tripleEDB}(O, X, \text{propertyConstant}, V) \wedge \\
&\text{unequal}(S, O)
\end{split}
\end{equation*}
While it is possible to set this constraint on qualifiers or references, this is currently not done and is thus not evaluated here.

\subsection{Allowed units (Q21514353)}\label{subsec_3_allowed_units}
The allowed units constraint needs to determine inequality between all allowed units and each unit on a constrained statement. To this end the units of a triple, qualifier or reference needs to be extracted during pre-processing and their inequality established. Quantities are rendered as string during pre-processing, specifying their value, bounds and unit. The new predicate unit\([2]\) will associate a value with its unit.\\

To determine if a violation occurred the unit to the constrained statement needs to be found. This is done via the unit-predicate as below
\begin{equation*}
\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \text{unit}(V, U)
\end{equation*}
with qualifiers and references working on the same lines.

The full rules require multiple unequal-atoms for all allowed units. Given a set \(A\) of constants, in this case allowed units, \(\text{unequal}(\{A\}, t)\) is short for the conjunction of the set \(\{\text{unequal}(a, t) | \forall a \in A\}\), with \(t\) being an arbitrary term.

Violation are thus
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \\
&\text{unit}(V, U) \wedge \text{unequal}(\{A\}, U)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_qualifier}&(S, I \text{propertyConstant}, V) \leftarrow \\
&\text{qualifierEDB}(S, \text{propertyConstant}, V) \wedge \\
&\text{unit}(V, U) \wedge \text{unequal}(\{A\}, U)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_reference}&(S, I \text{propertyConstant}, V) \leftarrow \\
&\text{referenceEDB}(S, \text{propertyConstant}, V) \wedge \\
&\text{unit}(V, U) \wedge \text{unequal}(\{A\}, U)
\end{split}
\end{equation*}

\subsection{Allowed qualifiers (Q21510851)}
The allowed qualifiers constraint is violated if a qualifier on a constrained statement exists that is different from all allowed qualifiers. During pre-processing all qualifiers on constrained statements will be extracted and the inequality of their properties and the allowed qualifiers established. We will use the notation for set inequality as introduced in section \ref{subsec_3_allowed_units}. With \(A\) the set of allowed qualifiers the rule is:
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \\
&\text{qualifierEDB}(S, Q, O) \wedge \text{unequal}(\{A\}, Q)
\end{split}
\end{equation*}

\subsection{One-of (Q21510859)}
The one-of constraint fits in the pattern established by the previous two constraints and disallows certain property-value combinations. Inequality is pre-processed between all values of constrained statements. With \(A\) the set of allowed values the rules for triple, qualifier and reference are respectively:
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \text{unequal}(\{A\}, V)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_qualifier}&(S, \text{propertyConstant}, V) \leftarrow \\
&\text{qualifierEDB}(S, \text{propertyConstant}, V) \wedge \text{unequal}(\{A\}, V)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_reference}&(S, \text{propertyConstant}, V) \leftarrow \\
&\text{referenceEDB}(S, \text{propertyConstant}, V) \wedge \text{unequal}(\{A\}, V)
\end{split}
\end{equation*}

\subsection{One-of qualifier value (Q52712340)}
The one-of qualifier value constraint is violated if a constrained statement has a qualifier with a value unequal to all allowed values. Inequality needs to be pre-processed between all values of qualifiers on constrained statements. With the set of allowed Values \(A\) the rules are
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \\
&\text{qualifierEDB}(S, \text{qualifierProperty}, O) \wedge \text{unequal}(\{A\}, O)
\end{split}
\end{equation*}

\section{Statement non-existence}\label{sec_statement_non-existence}
Multiple statements are violated if specific statements do not exist in relation to constrained statements. It is not possible to simply negate said statements and pre-processing every required statement would defeat the purpose of implementing them in datalog. However, non-existence can be derived utilising the order of statements. Three predicates are introduced: first\([2]\), last\([2]\), and next\([2]\), which denote the first and last statement of an item and the following statement to another using their statement IDs.\\

If qualifier non-existence should be tested the predicates have to be adapted, since they do not have a unique identifier. Their order has to be established using the entire set of statement ID, property and value. For this the predicates first\_qualifier\([3]\) and last\_qualifier\([3]\) taking the statement ID, the property and the value and next\_qualifier\([6]\) with ID, property and value for the current and next qualifier are introduced.\\

Using this pre-processed data the approach is to apply a require-predicate to each statement or qualifier. This is require\([2]\) for statements, connecting the statement ID with a required term \(t\) and require\([4]\) taking the statement ID, property, and value of a qualifier and linking this with the term \(t\).\\

For statements the pattern consists of two rules, both utilising the same conjunction \(c = C_1 \wedge .. \wedge C_m\) with arbitrary atoms \(C_n\) which is used to test if the statement does not fulfil the requirement. Then rule one
\begin{equation*}
\text{require}(S, t) \leftarrow \text{first}(S, I) \wedge c
\end{equation*}
states that the statement requires the condition and
\begin{equation*}
\text{require}(S, t) \leftarrow \text{next}(O, S) \wedge \text{require}(O, t) \wedge c
\end{equation*}
propagates this down the statement chain.

For qualifiers the rules are
\begin{equation*}
\text{require}(S, P, V, t) \leftarrow \text{first}(S, P, V) \wedge c
\end{equation*}
\begin{equation*}
\text{require}(S, P, V, t) \leftarrow \text{next}(O, X, C, S, P, V) \wedge \text{require}(O, X, C, t) \wedge c
\end{equation*}

If the last statement of an item or the last qualifier of a statement has require the violation occurred. In the following constraints only the conjunction \(c\) and adjustments to this pattern will be described. The require-propagation is regarded as given.

\subsection{Item requires statement (Q21503247)}
The item requires statement constraint requires the pre-processing of all item statements. Additionally, inequality between all properties of item statements and the required property as well as between all values and the allowed values has to be established. It occurs in two varieties, depending on if allowed values have been specified or not. The required term \(t\) is the  required property. Without separators the conjunction is \(c_1 = \text{tripleEDB}(S, I, P, V) \wedge \text{unequal}(\text{requiredPropertyConstant}, P)\).\\

If a set of allowed values \(A\) has been specified, a second set of require-rules have to be introduced with \(c_2 = \text{tripleEDB}(S, I, \text{requiredPropertyConstant}, V) \wedge \text{unequal}(\{A\}, V)\). Note that the first set of rules is still required, since the preceding statements do not need to have the required property.\\

In both cases violations can be found with
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \\
&\text{tripleEDB}(O, I, P, X) \wedge \text{last}(O, I) \wedge \\
&\text{require}(O, \text{requiredPropertyConstant})
\end{split}
\end{equation*}

\subsection{Value requires statement (Q21510864)}
The value requires statement constraint is syntactically very similar to the previous item requires statement constraint. Instead of requiring a statement on the item of a constrained statement it requires it on the value. The pre-processing changes to extracting all value statements along the constrained statements and ordering them. Inequality need to be computed between all properties and all values on value statements. The conjunctions remain the same and the final violation rule is
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \\
&\text{tripleEDB}(O, V, P, X) \wedge \text{last}(O, V) \wedge \\
&\text{require}(O, \text{requiredPropertyConstant})
\end{split}
\end{equation*}

\subsection{Inverse (Q21510855)}
The inverse constraint is similar to the value requires statement constraint in requiring a statement on a constrained value with a specific property. However, instead of putting no constraint or a list of fixed values on the required statements value it set a relative requirement: the constrained item. The pre-processing and inequalities thus remain the same, but the conjunctions change to 
\begin{equation*}
c_1 = \text{tripleEDB}(S, I, P, V) \wedge \text{unequal}(\text{inversePropertyConstant}, P)
\end{equation*}
\begin{equation*}
\begin{split}
c_2 = &\text{tripleEDB}(O, R, \text{propertyConstant}, X) \wedge \\
&\text{tripleEDB}(S, I, \text{inversePropertyConstant}, V) \wedge \\
&\text{unequal}(R, V)
\end{split}
\end{equation*}

\subsection{Symmetric (Q21510862)}
The symmetric constraint can be translated exactly as the inverse constraint if the inverse property where set to the same as the constrained property.

\subsection{Multi-value (Q21510857)}
The multi-value constraint requires a limited count of constrained statements. Alternatively, it could be said that if the item requires a second statement, the constraint is violated. Pre-processing extracts all items statements and inequality between all item statement properties as usual and the conjunction is \(c = \text{tripleEDB}(S, I, P, V) \wedge \text{unequal}(\text{propertyConstant}, P)\). The predicate require\_second\([2]\) is introduced with the same meaning as require except that it will be applied after a required property has been found:
\begin{equation*}
\text{require\_second}(S, \text{propertyConstant}) \leftarrow \text{next}(Q, R) \wedge \text{next}(R, S) \wedge \text{require}(Q) \wedge t
\end{equation*}
\begin{equation*}
\text{require\_second}(S, \text{propertyConstant}) \leftarrow \text{next}(R, S) \wedge \text{require\_second}(R) \wedge t
\end{equation*}
A violations would be any last statement requiring a second constrained statement.

\subsection{Single value (Q19474404)}\label{subsec_3_single_value}
The single value constraint can be divided into two different cases, depending on if the set of separators \(S\) is empty or not. Pre-processing needs to extract all item statements and their qualifiers and establish inequality between all statement IDs and all qualifier values.

\subsubsection{No separators}
If the separator set is empty, the violation simply occurs if there are two constrained statements on the same item. 
\begin{equation}\label{eq_no_separators_triple}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \\
&\text{tripleEDB}(O, I, \text{propertyConstant}, X) \wedge \\
&\text{unequal}(S, O)
\end{split}
\end{equation}
For qualifiers and reference there is no ID whose inequality could be checked. However, since the statement ID and the property of a possible conflict are always the same, inequality can be tested on the values.
\begin{equation*}
\begin{split}
\text{violation\_qualifier}&(S, \text{propertyConstant}, V) \leftarrow \\
&\text{qualifierEDB}(S, \text{propertyConstant}, V) \wedge \\
&\text{qualifierEDB}(S, \text{propertyConstant}, X) \wedge \\
&\text{unequal}(V, X)
\end{split}
\end{equation*}
\begin{equation*}
\begin{split}
\text{violation\_reference}&(S, \text{propertyConstant}, V) \leftarrow \\
&\text{referenceEDB}(S, \text{propertyConstant}, V) \wedge \\
&\text{referenceEDB}(S, \text{propertyConstant}, X) \wedge \\
&\text{unequal}(V, X)
\end{split}
\end{equation*}
\todo{Check if all reference-rules look exactly like the qualifier rules and cut them out if it is so.}

\subsubsection{With separators}\label{subsubsec_with_separators}
To find all violations under separators a number of things have to be considered. Only triples are eligible, since qualifiers cannot have further qualifier, and the order of qualifiers on constrained statements needs to be pre-processed as well since qualifier non-existence is relevant. The pattern needs to be applied for every separator, meaning the conjunction is: \(c = \text{qualifierEDB}(S, P, V) \wedge \text{unequal}(P, \text{separatorConstant})\) for each separator in \(S\).\\

With qualifier non-existence established the violation can be found. Two statements form a violation if they are distinct as per equation \ref{eq_no_separators_triple} and additionally fulfil the condition that all qualifiers are either equal or non-existent. \(\forall X \subset S, Y = S \setminus X\) the following rule has to be added. Note that \(qualifierEDB(S, {X}, [X])\) denotes one atom for each element \(x \in X\) as introduced in section \ref{subsec_3_allowed_units} with \([X]\) representing a variable which is distinct for each atom unless they have the same \(x\). With the predicate does\_not\_have\([2]\) linking a statement ID to the separator it does not have via \(\text{does\_not\_have}(S, R) \leftarrow \text{last\_qualifier}(S, P, V) \wedge \text{require}(S, P, V, R)\) for brevity the rules are
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \\
&\text{tripleEDB}(O, I, \text{propertyConstant}, W) \wedge \\
&\text{unequal}(S, O) \wedge \\
&\text{qualifierEDB}(S, \{X\}, [X]) \wedge \\
&\text{qualifierEDB}(O, \{X\}, [X]) \wedge \\
&\text{does\_not\_have}(S, \{Y\}) \wedge \\
&\text{does\_not\_have}(O, \{Y\})
\end{split}
\end{equation*}

\subsection{Mandatory qualifier (Q21510856)}
The mandatory qualifier constraint needs to determine qualifier non-existence on constrained statements to find violations, which is similar to section \ref{subsubsec_with_separators}. All constrained statements and their qualifiers have to be extracted and the order of the qualifiers pre-processed. Inequality must be established between all qualifier properties and the conjunction is \(c = \text{qualifierEDB}(S, P, V) \wedge \text{unequal}(P, \text{requiredPropertyConstant})\). With the usual require-pattern for qualifiers and the does\_not\_have rule added for brevity the violations would be
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \text{does\_not\_have}(S, \text{requiredPropertyConstant})
\end{split}
\end{equation*}

\subsection{Single best value (Q52060874)}
The single best value constraint, like the single value constraint (section \ref{subsec_3_single_value}), differentiates between the set of separators \(S\) being empty or not. Since the constraint depends on the rank of statements this needs to be extracted during pre-processing and attached to the statement ID with the new predicate rank\([2]\). Qualifiers and references are not affected since they do not have ranks. For this constraint all item statements, their rank and their qualifiers need to be extracted and inequality established between the statement IDs and the qualifier values.\\

\subsubsection{No separators}
If the separator set is empty, the violation simply occurs if there are two constrained statements on the same item with the preferred rank. Thus the equation \ref{eq_no_separators_triple} is expanded to
\begin{equation}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \\
&\text{rank}(S, \text{preferredRankConstant}) \wedge \\
&\text{tripleEDB}(O, I, \text{propertyConstant}, X) \wedge \\
&\text{rank}(O, \text{preferredRankConstant}) \wedge \\
&\text{unequal}(S, O)
\end{split}
\end{equation}

\subsubsection{With separators}
As in the case above, the qualifier non-existence and violation rules are very similar to single value. The only change is the addition of the rank requirements as shown below.
\begin{equation*}
\begin{split}
\text{violation\_triple}&(S, I, \text{propertyConstant}, V) \leftarrow \\
&\text{tripleEDB}(S, I, \text{propertyConstant}, V) \wedge \\
&\text{rank}(S, \text{preferredRankConstant}) \wedge \\
&\text{tripleEDB}(O, I, \text{propertyConstant}, W) \wedge \\
&\text{rank}(O, \text{preferredRankConstant}) \wedge \\
&\text{unequal}(S, O) \wedge \\
&\text{qualifierEDB}(S, \{X\}, [X]) \wedge \\
&\text{qualifierEDB}(O, \{X\}, [X]) \wedge \\
&\text{does\_not\_have}(S, \{Y\}) \wedge \\
&\text{does\_not\_have}(O, \{Y\})
\end{split}
\end{equation*}

\subsection{Type (Q21503250)}
\todo[inline]{Well. I wouldn't know. I'd have to expand the require pattern to search up the subclass tree and if require arrives at the root the class is not there. But a) its not a tree, so that does not work and b) there is no single root.\\
Alternatively I could compute each items class via transitivity aaaand.... well. Violation if items classes unequal required class, but how to write that? Well, maybe I'll get a brilliant idea. Or I'll stop being stupid in case this does not require a brilliant idea.}

\subsection{Value type (Q21510865)}
\todo[]{as above, so below. no wait...}

\chapter{Evaluation/Comparison}

\section{Inequality evaluation}\label{sec_inequality_evaluation}
\end{document}
